Source: [US9361223B1](https://patents.google.com/patent/US9361223B1)

# [US9361223B1](US9361223B1.md) - [US9361223B1](US9361223B1.md) - Storage method and apparatus for random access memory using codeword storage

## Details

* Date: 2012-05-14
* Inventor: Kandou Labs SA
* Beneficiary: Harm Cronie, Amin Shokrollahi

## Other patents

### Backwards
 * US3196351A
 * US3636463A
 * US3939468A
 * US4163258A
 * US4181967A
 * US4206316A
 * US4276543A
 * US4486739A
 * [US4499550A](US4499550A.md)
 * US4774498A
 * US4864303A
 * US4897657A
 * [US4974211A](US4974211A.md)
 * US5053974A
 * [US5166956A](US5166956A.md)
 * US5168509A
 * US5283761A
 * US5287305A
 * [US5412689A](US5412689A.md)
 * US5459465A
 * US5511119A
 * US5553097A
 * US5599550A
 * US5659353A
 * [US5825808A](US5825808A.md)
 * US5875202A
 * US5945935A
 * US5995016A
 * US5999016A
 * [US6005895A](US6005895A.md)
 * [US6084883A](US6084883A.md)
 * US6119263A
 * US6172634B1
 * US6175230B1
 * US6232908B1
 * [US6278740B1](US6278740B1.md)
 * US6346907B1
 * US20020044316A1
 * US20020057592A1
 * US6404820B1
 * US6417737B1
 * [US6452420B1](US6452420B1.md)
 * US6483828B1
 * US6509773B2
 * [US6556628B1](US6556628B1.md)
 * US6563382B1
 * JP2003163612A
 * US20030146783A1
 * US6621427B2
 * US6650638B1
 * [US6661355B2](US6661355B2.md)
 * US6686879B2
 * [US6766342B2](US6766342B2.md)
 * US6839587B2
 * [US6839429B1](US6839429B1.md)
 * US6854030B2
 * US20050057379A1
 * US6898724B2
 * US6927709B2
 * US20050174841A1
 * US20050213686A1
 * [US6954492B1](US6954492B1.md)
 * US6963622B2
 * US6973613B2
 * US6976194B2
 * US6982954B2
 * [US6990138B2](US6990138B2.md)
 * [US6999516B1](US6999516B1.md)
 * US7023817B2
 * US7053802B2
 * US7075996B2
 * US7085153B2
 * US7085336B2
 * [US7142612B2](US7142612B2.md)
 * US7142865B2
 * US7164631B2
 * US7167019B2
 * [US7180949B2](US7180949B2.md)
 * US20070188367A1
 * US7269212B1
 * US20070263711A1
 * US7339990B2
 * US7349484B2
 * US7348989B2
 * US7356213B1
 * US7358869B1
 * US20080104374A1
 * US7370264B2
 * [US7389333B2](US7389333B2.md)
 * US7456778B2
 * US7462956B2
 * US7496162B2
 * US20090059782A1
 * US7535957B2
 * CN101478286A
 * WO2009084121A1
 * US7570704B2
 * US7599390B2
 * US7616075B2
 * [US7633850B2](US7633850B2.md)
 * US7639596B2
 * US7656321B2
 * US20100046644A1
 * WO2010031824A1
 * US7694204B2
 * US7706456B2
 * US7706524B2
 * US7746764B2
 * US20100180143A1
 * US7787572B2
 * US7804361B2
 * US7808883B2
 * US7882413B2
 * US7899653B2
 * US7933770B2
 * WO2011119359A2
 * US8036300B2
 * US8050332B2
 * US8055095B2
 * US8064535B2
 * [US20110299555A1](US20110299555A1.md)
 * US8085172B2
 * US8091006B2
 * US8106806B2
 * [US8159376B2](US8159376B2.md)
 * US8159375B2
 * US8180931B2
 * US8185807B2
 * US8199849B2
 * US8199863B2
 * US20120161945A1
 * US8218670B2
 * US8245094B2
 * US8279094B2
 * US8295250B2
 * US8310389B1
 * US20130010892A1
 * US8365035B2
 * EP2039221B1
 * US8429495B2
 * US8442099B1
 * US8443223B2
 * US8451913B2
 * US8462891B2
 * US8472513B2
 * US8520348B2
 * US8539318B2
 * US8547272B2
 * US8577284B2
 * US8578246B2
 * US8588280B2
 * US8588254B2
 * US8593305B1
 * US8649445B2
 * US8649556B2
 * US8649840B2
 * US8711919B2
 * US8718184B1
 * US8773964B2
 * US8782578B2
 * US8897134B2
 * US20150010044A1
 * US8975948B2
 * US20150078479A1
 * US8989317B1
 * US9020049B2
 * US9077386B1
 * US20150199543A1
 * US9106465B2
 * US9124557B2
 * US9172412B2
 * US9197470B2
### Forward
 * 
## Abstract

Abstract

A memory circuit, such as an embedded DRAM array, stores information as groups of bits or data using information coding in storage and retrieval data, instead of each bit being stored separately. Write data words can be mapped to storage format words that are stored and defined by a Hadamard matrix. The storage format word is stored as charge levels in an addressable memory location. For retrieving stored data, charge levels are read from the storage cells and interpreted to a valid storage format word. Hadamard code maximal likelihood decoding can be used to derive a read data word corresponding to a previously written write data word. The write data word is then output as the result of a read of the selected addressable location, or a portion thereof. The mapping can be two or more Hadamard matrix mappings concatenated for each of a plurality of storage format words.



A memory circuit, such as an embedded DRAM array, stores information as groups of bits or data using information coding in storage and retrieval data, instead of each bit being stored separately. Write data words can be mapped to storage format words that are stored and defined by a Hadamard matrix. The storage format word is stored as charge levels in an addressable memory location. For retrieving stored data, charge levels are read from the storage cells and interpreted to a valid storage format word. Hadamard code maximal likelihood decoding can be used to derive a read data word corresponding to a previously written write data word. The write data word is then output as the result of a read of the selected addressable location, or a portion thereof. The mapping can be two or more Hadamard matrix mappings concatenated for each of a plurality of storage format words.

CROSS-REFERENCES TO PRIORITY AND RELATED APPLICATIONS
This application is a continuation of U.S. application Ser. No. 13/844,032, filed Mar. 15, 2013, which claims the benefit of U.S. Provisional Patent Application No. 61/646,790, filed May 14, 2012, entitled “STORAGE METHOD AND APPARATUS FOR RANDOM ACCESS MEMORY USING CODEWORD STORAGE”, the entire disclosure of which is incorporated by reference herein for all purposes.
FIELD OF THE INVENTION
The present invention relates generally to methods and apparatus for storage and retrieval of information on memory units and more particularly to structured storage.
BACKGROUND OF THE INVENTION
Memory storage is a constantly advancing field, as there is continued demand for larger memory capacities, at lower cost, lower power consumption per unit of storage and faster storage and retrieval speeds. There are different technologies that are in common use.
Storage of digital data as capacitive charges in a dynamic memory structure is well represented in the literature. Optimized logic design, innovative physical structures, and targeted semiconductor process improvements have been applied to create high density, high performance dynamic memory components of significant performance, capacity, and economy. Thus, the particular semiconductor technology used for large memory chips, such as dynamic random access memory (DRAM) chips, has been the topic of much research and DRAM technologies have been highly refined.
However, there is also a demand for comparatively small amounts of memory within, for example, a custom or semi-custom semiconductor logic device that uses a different technology. As such devices are based on different semiconductor processes and layout rules than are used to create DRAM devices, few of the optimizations developed for dedicated DRAMs are applicable to these embedded memory designs. Instead, the memory portions of such devices typically rely on planar capacitive structures of relatively low capacitance and relatively large area. Use of such relatively low capacitance, non-optimized cells can result in reduced signal output on a read operation, since readout of the stored charge is divided between the lower cell capacitance and the relatively fixed sense line parasitic capacitance. Mitigation of this effect requires the use of larger storage elements, significantly increasing the semiconductor area required for the embedded storage array.
As a result, improvements in structural design of memory would be useful.
BRIEF SUMMARY
In embodiments of a memory circuit according to aspects of the present invention, an embedded DRAM array stores information as groups of bits or data using information coding in the storage and retrieval of stored data, instead of each bit being stored separately.
In some embodiments, data is organized into data words, wherein each data word is representable as a vector having a plurality of components. In specific embodiments, the components are bits, in that they have one of two possible values. A data word that is to be stored into memory is mapped from a write data word to a storage format word. The mapping can be a mapping defined by a Hadamard matrix. The storage format word is stored as charge levels in an addressable location of the memory. An addressable location of the memory is a selectable subset of the memory is a plurality of storage cells wherein a plurality of bits of information can be stored.
For retrieving stored data, an addressable location is selected, charge levels are read from the plurality of storage cells activated when the addressable location is selected, and the charge levels are interpreted to a valid storage format word. The interpretation can be according to a maximal likelihood decoding according to a Hadamard code to derive a read data word corresponding to a previously written write data word. The write data word is then output as the result of a read of the selected addressable location, or a portion thereof.
In various embodiments, the characteristics of groups of bits are written and read collectively and optimized through the application of information coding techniques.
In a specific embodiment, an input word of B bits is mapped to an expanded word of S bits (S>B) for storage in a dynamic memory array as stored charge on S cells. On subsequent readout, the charge levels of the S cells are interpreted by an inverse mapping component that the memory device uses to reconstruct the original B bit values from the S possibly degraded signals.
In some embodiments, the mapping is a Hadamard matrix and in some embodiments, the mapping is two or more Hadamard matrix mappings concatenated for each of a plurality of storage format words.
The addressable location can be a row selection of a two-dimensional array of storage cells, such that the storage cells that collectively store a storage format word have a row selection in common. The maximal likelihood decoding can be a Fast Walsh Transform. The Hadamard code used for mapping can correspond to the Walsh codes of individual rows in a Hadamard matrix or a superposition of a plurality of Walsh codes of individual rows in a Hadamard matrix. Mapping can incorporate a distribution operation that spreads the write data word across multiple Hadamard encodings comprising the larger storage format word, and reading includes combining the result of multiple Hadamard decodings to produce the read data word. The write data word and/or the storage format word can incorporate additional error detection or error correction bits.
The following detailed description together with the accompanying drawings will provide a better understanding of the nature and advantages of the present invention.

BRIEF DESCRIPTION OF THE DRAWINGS
 FIG. 1 is a schematic diagram showing the elements of a conventional DRAM architecture.
 FIG. 2 illustrates examples of several Hadamard matrices.
 FIG. 3 shows the basic transform operations performed in an example embodiment.
 FIG. 4 is a schematic diagram of Hadamard encoded storage in a DRAM array.
 FIG. 5 illustrates multiple instances of Hadamard encoded storage combined into a larger system.
 FIG. 6 illustrates another example.

DETAILED DESCRIPTION OF THE INVENTION
In embodiments of a memory circuit described herein, data is stored into memory, such as an embedded dynamic random access memory (“DRAM”) device. Since the device is random access, it has a plurality of addressable storage locations and thus a write operation involves providing the device with a selection of an addressable storage location and write data, whereas a read operation involves providing the device with a selection of an addressable storage location and obtaining therefrom the read data.
 FIG. 1 illustrates a conventional dynamic memory array architecture that operates in this manner. Generally, the memory is organized as a two-dimensional array of M×N storage cells, for some integers M and N. Each storage cell typically comprises a cell select transistor 105 and a capacitive storage element 106, as illustrated. The address of the selected memory location can comprise a binary value of some fixed number of bits (e.g., log2(M*N) with M and N being integer powers of two). The address can be partitioned into a log2(M) portion referred to as a “row selection” and a log2(N) portion referred to as a column selection.” Thus, a portion of a memory address input to the memory device is decoded as a row selection address 102 to enable one of M row selection lines 104 in the array. Connected to N cell select transistor gates, the enabled row selection line turns on the associated cell select transistors 105, connecting their capacitive storage elements 106 to N column sense lines 107, allowing any charge stored on the storage capacitors to be presented as a voltage on their associated column sense lines. These voltages are measured by sense amplifiers 108, each indicating whether that column's selected cell contained a charge or no charge. The detected signals are presented as column data 109 to a column data selection multiplexor 112, which uses the column selection portion of the memory address as a column address 111 to select the portion of the column data 109 to present to data line 113, i.e., the bit value stored in the capacitive storage element 106 that is at the location in the array specified by the row selection portion and the column selection portion of the input address.
Because this DRAM read operation has drained charge from the DRAM array storage capacitors 106, a refresh operation must be performed to restore the stored data. This is done by enabling write data column drivers 110 after the sense amplifiers 108 produce their result. This drives the column data 109 back onto the column sense lines 107, recharging the DRAM array storage capacitors 106. That operation complete, the row selection line 104 is disabled, returning all cell select transistors 105 to an off state and again trapping charge in the capacitive storage elements 106.
A DRAM write cycle is performed similarly to the described read cycle, except that external write data is caused to flow from data line 113 back through the column data selection multiplexor 112 to force the sense amplifier 108 state to the desired value, causing the new data to be written to the DRAM cells as part of the concluding refresh operation. As stored charge is subject to leakage currents, it is necessary to periodically refresh (that is, perform the described read/restore operation on) each cell in the array before its charge decays to an unreadable level.
Common embodiment variations from the example of FIG. 1 include support for automatic refresh operations, use of differential sense amplifiers which measure the difference in signal between column sense lines connected to selected row cells and non-selected row cells, and column data selection multiplexing to support wider external data widths than the single data line 113 shown as an example. Current designs expand the described row/column addressing structure to encompass millions of rows and thousands of columns, often embodied as multiple banks of DRAM cell arrays within a single device.
In an ideal DRAM design, the capacitance of each storage element is identical and relatively large compared to the parasitic capacitance of the row line and sense amplifier input, and the capacitive leakage current is extremely small. These characteristics translate into a high and uniform signal level when a charged cell is read, and a long retention time between necessary refresh operations. Dedicated DRAM devices are fabricated using semiconductor processes optimized for these characteristics, capable of creating compact, high capacitance storage cells with extremely low leakage characteristics. Such process characteristics are not generally available for dynamic memory designs that are embedded within a custom or semi-custom digital logic device, as the processes used there are typically optimized for logic speed and density rather than low leakage and the ability to fabricate deep trench structures as are used to create optimized DRAM capacitive cells. Instead, designers of embedded dynamic memory arrays typically adapt available design library elements to this purpose, such as using the parasitic capacitance of a standard transistor element as a storage capacitor. Obtaining the necessary storage capacitance with such a structure requires significant planar area, so that the overall space required for the memory system is constrained by the total size of the storage array elements, rather than by minimum feature size or array signal line density as in a dedicated DRAM device.
In the example of FIG. 1, it is the case that more than one bit is read or written at a time, typically something like N bits at a time, even though the memory chip might only output less than N bits in response to a read operation or be asked to write less than N bits at one time. Memory systems are internally structured as collections of multiple bits that are read and written in parallel, although it is typically the case that the bits that are stored are independent of each other, i.e., when N bits are presented for storage, they are each stored in their own storage cell as a charge, and the same for reading.
Encoding Data as Storage Group Codes
In novel approaches described herein, when a memory device is presented with an address and data to be written, the data to be written is formed into a write data word, the memory device (such as a memory portion embedded in a circuit or chip that has other processing functions) maps the write data word into a storage format word and stores the storage format word. The write data word and the storage format word are both representable as vectors, i.e., they have a plurality of components, typically those components being bits, wherein a bit is a memory, data and/or information element that can have one of two possible logical values with physical representations that may be approximations of their logical value. Thus, in a specific embodiment, the write data word is a multi-bit value and the storage format word is also a multi-bit value. Herein, the length of the write data word is represented by an integer B, whereas the length of the storage format word is represented by an integer S. Where the length B write data word can take on up to 2B different possibilities, S will be greater than B. As explained below, the S bits of a storage format word are not independent, but are defined by a codeword mapping between write data words and storage format words.
Whereas storing data involves providing the memory device with an address and a write data word, which is converted to a length S storage format word that is then stored into S memory cells, reading involves retrieving, according to the selected addressable location, charge levels from the S storage cells activated when the addressable location is selected, determining the length S storage format word and inverse mapping, preferably using a maximal likelihood decoding according to a Hadamard code to derive a read data word corresponding to a previously written write data word. The write data word is then output as the result of a read of the selected addressable location, or a portion thereof.
Of course, it may be that fewer than B bits are written at a given write operation or fewer than B bits are read. In such cases, it may be that the memory device fills in some of the bits during a write with bits of the write data word that was mapped and stored (which may involve an inverse mapping to figure out those bits) and for reading, some of the steps are skipped for some bits or some of the resulting read data word are discarded before outputting fewer than B bits. In various embodiments, the characteristics of groups of bits are written and read collectively and optimized through the application of information coding techniques. In a specific embodiment, an input word of B bits is mapped to an expanded word of S bits (S>B) for storage in a dynamic memory array as stored charge on S cells. On subsequent readout, the charge levels of the S cells are interpreted by an inverse mapping component that the memory device uses to reconstruct the original B bit values from the S possibly degraded signals.
As explained in more detail elsewhere herein, a unique approach to memory design can improve embedded DRAM arrays. Rather than attempting to improve the signal characteristics of a single bit, e.g., through increased storage capacitance, the characteristics of groups of bits written and read collectively are optimized through the application of information coding techniques. Thus, an input word of B bits is mapped to an expanded word of S bits for storage in a dynamic memory array as stored charge on S cells. On subsequent readout, the charge levels of the S cells are interpreted by an inverse mapping component that reconstructs the original B bit value from the S degraded signals. For practical memory array capacities and word lengths, the increased array density available through reduction in the size of individual storage elements needed to obtain the same system bit error rate with use of the described coding technique more than compensates for the added storage elements required.
Encoding Data as Storage Group Codes—Specific Examples
In one specific example of a memory device, storage is constructed such that the storage format words are S=N−1 bits, where N is an integer power of two, the mapping is according to a size N Hadamard matrix size, and the write data word size is B=log2(N)−1 bits. FIG. 2 shows examples of Hadamard matrices of size N=2, N=4, and N=8. Combinations of values meeting those constraints are illustrated in Table 1.



 
 
 
 
TABLE 1
 
 
 
N
Storage group size (N-1)
Stored data width (B)
 
 
 
 8
 7 bits
2 bits
 
16
15 bits
3 bits
 
32
31 bits
4 bits
 
64
61 bits
5 bits
 
 
 







Hadamard matrices of size 2N+4 are also known, and are equally applicable in embodiments based on the described method. For example, a 20×20 Hadamard matrix created using Paley's construction may be used to store four bits of data in a storage group of 20 cells.
To encode a data value, K, in the range 0≦K≦2B, a numerical vector v is created of length N with the value “1” in the first position (first component), the value “−1” in the K+1-th position, and all other positions zero. For purposes of illustration, the values N=8 and B=2 will be used, allowing possible data values of {0, 1, 2, 3}, which are encoded as the numeric vectors as indicated in Table 2. It should be apparent upon reading this disclosure how to use other values for N and B.



 
 
 
 
 
TABLE 2
 
 
 
 
 
Write Data Word
Numerical Vector (v)
 
 
 
 
 
0 (e.g., 00)
(1, −1, 0, 0, 0, 0, 0, 0)
 
 
1 (e.g., 01)
(1, 0, −1, 0, 0, 0, 0, 0)
 
 
2 (e.g., 10)
(1, 0, 0, −1, 0, 0, 0, 0)
 
 
3 (e.g., 11)
(1, 0, 0, 0, −1, 0, 0, 0)
 
 
 
 







 FIG. 3 illustrates this example with a numeric vector 330 encoding the value “2”, which may be seen by the presence of a “−1” in the fourth location 331. The chosen numerical vector is then multiplied by the Hadamard matrix H3 and the result scaled by ½ to obtain the possible binary results listed in Table 3.



 
 
 
 
 
TABLE 3
 
 
 
 
 
Write Data Word
Storage Format Word
 
 
 
 
 
0
(0, 1, 0, 1, 0, 1, 0, 1)
 
 
1
(0, 0, 1, 1, 0, 0, 1, 1)
 
 
2
(0, 1, 1, 0, 0, 1, 1, 0)
 
 
3
(0, 0, 0, 0, 1, 1, 1, 1)
 
 
 
 







This is illustrated in FIG. 3 where the operation 332 is performed, producing the binary result 333. It should be noted that the described procedure creates binary results that correspond directly to the Walsh functions that make up the (K+1)-st row of the Hadamard matrix, where a “1” in the matrix corresponds to a binary zero, and a “−1” in the matrix corresponds to a binary one. Other embodiments may apply this equivalence to directly encode the binary results using Boolean logic or a lookup table.
Given the described construction of the numerical vector, the initial bit of the resulting binary results sequence will always be zero, and thus need not be stored but instead may be represented by the fixed value “0” on readout. The remaining seven bits of the sequence are stored in a group of seven storage cells, preferably accessed simultaneously and in parallel, such as seven array elements selected by the same array row address. For example, the sequence 333 will have its initial zero suppressed and may then be stored in seven storage cells as the sequence (1, 1, 0, 0, 1, 1, 0) to represent the data value “2” as encoded above.
In general, where a value K with 0≦K<2B is chosen, a vector v is created that has a “+1” at its first position, a “−1” at position K+1, and zeroes everywhere else, and the vector w=½*HN+1*v is formed that consists of zeroes and ones only. The entries of the vector w, except possibly the first which is always zero, can be stored on N−1 cells. In general, it is also possible to use values of K between 0 and N−2, leading to N−1 choices for K. In that case, a mapping is needed that maps bits to the N−1 possible values of K. Some techniques to this end are described hereinbelow.
Decoding Data Values from Readout Charge Levels
On subsequent readout, the signals obtained from the same storage group of cells will be degraded by cell leakage and noise. Continuing the previous example, a vector v of relative values may be obtained by taking the fixed value of “0” (described above) in the first position, followed by the values obtained by reading the seven (or more generally, N−1) storage cells written with the previous sequence. An example result is shown as 334, with individual values representing both leakage decay of stored “1” values, which may vary from cell to cell, and noise-induced variation of all signal levels.
The Hadamard transform of this vector 334 is taken at 335, producing the result 336. It may be noted that the overall form of this result vector 336 is the same as that used to generate the numerical vector 330 used for storage; that is, a significantly positive value, followed by some arrangement of one significantly negative value 337 and six values near zero. In the ideal case having neither signal level degradation nor noise, the sequence read from the storage cells would be a series of “1” and “0” values, and the result vector obtained after the matrix multiplication would exactly match the original numeric vector used in the encoding process.
Given knowledge of this expected form, conventional techniques may be applied to identify which of the possible variations of that form (i.e., which of the possible numeric vectors that could have been used for the storage operation) is the greatest likelihood match of 336 to one of the possible numeric vectors which could have produced it. One embodiment performs this match by finding the most negative value in 336, here −0.366 in the fourth position 337, which corresponds to the encoding method's representation of the value K=2 as a “−1” value 331 in the fourth position of the original numerical vector 330 of this example.
Some embodiments may use an equivalent operation to the Hadamard transform, such as a Fast Walsh transform. Other embodiments may incorporate additional consistency checks of the readout transformed sequence to further verify it is of the same overall form expected for an encoded sequence, such as having its most positive value in the first position, that the values approximating zero have amplitudes below a set threshold, etc.
Storage Cell Scaling Reduction of Array Size
The above example utilizes seven storage cells to encode a two bit value, which appears to be a significant storage inefficiency. Indeed, for higher values of N, this apparent cells/bit inefficiency only appears to grow. However, systems with larger matrix size (that is, larger N) also display significantly improved decoding gain, in other words an ability to tolerate lower signal to noise ratios on readout.
A study and error analysis of the overall system using a second moment analysis over random perturbations showed that the necessary array capacitance (or equivalently, the required area of the array storage cell) may be scaled down by a factor of around 2/N while maintaining the same overall bit error rate. Depending on the topology used for detection of the signals, actual scale downs of between 2/N and 4/N may be suitable. Including this scale improvement factor, the overall array size reduction obtainable over a conventional one bit/cell array for some example matrix sizes is as shown in Table 4.



 
 
 
 
 
 
 
 
TABLE 4
 
 
 
 
 
 
Cells/
2/N scale 
4/N Scale 
Overall Scale 
 
 
Matrix
Bit 
Factor
Factor
Factor
 
 
 
 
 
H3 
 7/2
¼ 
½ 
0.875-1.75 
 
 
H4 
15/3
⅛ 
¼ 
0.625-1.3 
 
 
H5 
31/4
 1/16
⅛ 
 0.484-0.9688
 
 
H6 
63/5
 1/32
 1/16
0.3938-0.7875
 
 
H7 
64/3
 1/64
 1/32
0.333-0.666
 
 
 
 







Scaling of array storage elements will affect the required refresh rate if standard sense amplifier signal level refresh is used. Some embodiments instead implement refresh at the data bit level rather than the array bit level, performing the full Hadamard decode and encode for each refresh cycle. Other embodiments may simplify that behavior by decoding only to the point of determining which matrix row (e.g., Walsh function) best matches the readout data pattern, followed by a write back of that row's Walsh function bit pattern. Embodiments utilizing more complex data encoding patterns may extend that method to a best match of superpositions of Walsh functions.
Integration of Storage Group Coding into a DRAM Subsystem
 FIG. 4 shows an exemplary embodiment of Hadamard encoded storage in a DRAM array. DRAM array 441 comprises a multiplicity of DRAM array cells, each connected to one of M row selection lines 444 and one of N column sense lines 447. When enabled by a selected row selection line 444, the attached DRAM element pass transistor 445 connects its associated DRAM element storage capacitor 446 to a column sense line 447.
Concurrently, data to be written 449 is encoded by a write data mapping operation 450 into a vector of encoded values, which undergoes a Hadamard encoding operation 451 to create a Hadamard encoded storage word 452 that can be placed on a set of wires or a bus as illustrated. It should be understood that the “operation” elements shown in FIG. 4 could be implemented with dedicated circuitry or the like that implements the transformations, mapping, etc. described elsewhere herein. It should also be understood that, depending on context, the references in the figures may refer to wires or channels, but might refer to the data carried on those wires or channels.
The individual values of the Hadamard encoded storage word 452 are driven by encoded write data drivers 453 onto the column sense lines 447, creating a pattern of charged cells in the selected DRAM element storage capacitors 446. All row selection lines 444 are then disabled, trapping the stored charges in the array cells.
Subsequently, the same row address 442 is presented to row address decoder 443, enabling one of the row selection lines 444. When enabled by the selected row selection line 444, each of the attached DRAM element pass transistors 445 for that row connects its associated DRAM element storage capacitor 446 to a column sense line 447. The charge stored on the DRAM element storage capacitor 446 presents a voltage on the column sense line 447, which is detected by the sense amplifier 448. The detected signals pass through a Hadamard decoder 454 (as might be implemented to match the logic described above for inverse mapping) and the results provided to a read data decoder 455 that then performs greatest likelihood matching and outputs results as a decoded read data word 456. Finally, information from the read operation may be returned along a channel 455 to a Hadamard encoder operation 451 to produce Hadamard encoded storage format words to be written back through encoded write data drivers 453 to DRAM array 441.
In some embodiments, Hadamard encoding operation 451 is implemented as a circuit that performs a Hadamard transform, i.e., it transforms its input according to a Hadamard transform, such as one described herein, and provides the result as its output. In a specific circuit implementation, a resistor network encodes for the Hadamard transform and the transform can be performed quickly and without undue overhead. In some embodiments, Hadamard decoding operation 545 is also done with a resistor network and decoder 455 is a circuit that performs peak detection to find the position of a vector that has the lowest entry.
Improved Storage Encoding Efficiency
A practical storage system is often desired, to handle data significantly wider than the two bit data width of the previous example. For example, the size of the write data words might be bytes (8 bits) or words (16 bits) rather than two bits. In one approach that addresses this need, such systems incorporate multiple instances of the mapper. For example, four instances of the N=8/B=2 Hadamard mapper might be used in parallel, each handling two bits to support an overall storage interface width of eight bits.
Simply paralleling multiple embodiments in this fashion does not provide the most efficient utilization of storage resources and further improvements are possible. Consider the previous N=8 encoding example. Additional encoded values are possible within the described numerical vector format. For example, a numerical vector formatted as a single “1” followed by some combination of a single “−1” and six zeroes can encode seven different values, where the example only employed four of those. To take advantage of these additional states in a multiple-instance system, an additional information spreading procedure may be applied.
As a simple example, two N=8 subsystems, N1 and N2, as described in the earlier example can actually represent 7*7=49 distinct sets of states, which is more than the 32 states needed to represent any five bit value. But, taken individually, the subsystems N1 and N2 cannot take advantage of those additional states, as by itself neither can represent enough states to encode an additional bit.
Consider now that a five bit vector, V=V3, V2, V1, V0), is to be mapped to the states of the two N=8 subsystems, N1 and N2. One simple information spreading procedure to map the five bit binary value of V to the states 0 to 5 on each of N1 and N2 uses the following procedure:
1) If V4=0, encode states N1={0, 1, 2, 3} and N2={0, 1, 2, 3} as:
    N1=2*V4+V3, and N2=2*V2+V1     
If V4=1 and V3=0, encode states N1={0, 1, 2, 3} and N2={4, 5} as
    N1=2*V2+V1, and N2=4+V0     
If V4=1 and V3=1, encode states N1={4, 5} and N2={0, 1, 2, 3}
    N1=4+V0, and N2=2*V2+V1     
As previously described, the resulting states N1 and N2 are then encoded as numeric vectors ranging from 0=(1, −1, 0, 0, 0, 0, 0, 0) to 5=(1, 0, 0, 0, 0, 0, −1, 0) and those numeric vectors are each separately multiplied by the Hadamard matrix H3 and the result scaled by ½ to obtain the possible binary results to be stored in the two seven-bit storage groups of cells. Extending this example, a Boolean logic layer or lookup table can be used to map an 8 bit value to three 1-of-7 state values (since 7*7*7=343 and 343>256, so all eight bit numbers can be distinctly represented) which are then encoded for storage in three N=8 subsystems.
On readout, the voltage levels obtained from the seven-bit storage groups of cells are decoded as previously described to obtain state values, which are then applied to an inverse lookup table or Boolean logic layer to reconstruct the original binary value (five bits from two storage groups of cells in the first example, eight bits from three storage groups of cells in the extended example.)
 FIG. 5 illustrates multiple embodiments such as shown in FIG. 4 combined into a larger system in this fashion. Input data to be written to the storage system 561 undergoes a data spreading and encoding operation 562, creating sets of state vectors 563 which in combination represent the input data 561. Each of the state vectors 563 undergoes Hadamard matrix encoding 564 to produce sets of Hadamard encoded write data 565 that are stored in DRAM array 566. Subsequently, the same DRAM array elements are read, producing sets of Hadamard encoded read data 567 which undergo Hadamard matrix decoding 568, producing multiple decoded state vectors 569 which are presented to the data aggregation and decoding operation 570, to produce the output data result 571.
The particular mapping processes, circuits and/or structures used to first spread and later combine the data provide a unique mapping between input value to state values to output value, and should do so with relatively uniform distribution over the available set of state values, but otherwise may be chosen based on implementation convenience. On encoding, an embodiment may combine the mapping or information spreading and the encoding operations, directly producing multiple Hadamard-coded storage values based on an input value. Similarly, an embodiment of the decoding operation may combine Hadamard decoding and the inverse mapping or combining action in a single operation, or may selectively implement some portions as parallel operations.
With this enhanced encoding, the delivered storage density for some example stored data widths and matrix complexities are as shown in Table 5.



 
 
 
 
 
 
 
 
TABLE 5
 
 
 
 
 
Sub-
Data 
Storage 
Cell Scale 
Overall Scale 
 
 
systems
bits (B)
Bits (S)
Factor
Factor
 
 
 
 
 
3 × H3 
 8
 3 * 7 = 21 
¼ 
0.656
 
 
5 × H4 
19
5 * 15 = 75 
⅛ 
0.493
 
 
7 × H5 
34
7 * 31 = 217
 1/16
0.399
 
 
6 × H6 
35
6 * 63 = 378
 1/32
0.337
 
 
 
 







As may be seen from this disclosure, even a fairly simple implementation based on 8×8 Hadamard matrices or the equivalent Fast Walsh-Hadamard transform may require as little as 66% of the semiconductor area of an embedded dynamic memory subsystem designed using conventional techniques.
More Complex Encoding Methods
The previous examples utilize an encoding of data bits in a numeric vector which, when transformed by the Hadamard matrix, produces a binary storage pattern corresponding to a single Walsh function. This selection of patterns provides certain benefits with respect to high correlation within the decoding process and a result vector having a simple to analyze form. However, higher storage efficiency might sometimes be desired, using fewer storage bits to store a given number of data bits.
Other tradeoffs are possible; one embodiment utilizes numeric vectors of the form “2” followed by a sequence containing two “−1” values and all other values zero. When multiplied by the Hadamard matrix in the encoding process, and divided by 4, such a pattern produces a result that is the equivalent of the additive superposition of two Walsh functions, rather than the binary representation of a single Walsh function of the earlier example. That is, a range of charge levels is stored in particular cells within the selected storage group to represent the encoded sequence, rather than the binary selection of a single charge level or no charge per cell.
On decoding, analysis of the result vector obtained after the Hadamard matrix operation is similarly interpreted relative to this more complex expected pattern having significantly negative values in two positions. The additional degree of freedom allows significantly more states to be encoded, thus permitting higher storage efficiency at the cost of more complex processing functions and somewhat lower noise immunity.
 FIG. 6 provides an example. There, a vector 630 is encoded in this example. This vector has a “2” at position 1, and two “−1”s at positions 4 and 6, indicated by 631. The Hadamard transform of this vector, scaled by ¼, is computed in 632 to obtain the resulting vector in 633 having coordinate values 0, ½, and 1. These values may be stored on the eight cells. An example of a vector of charges read from the cells is shown as 634, with individual values representing both leakage decay of stored “1” values, which may vary from cell to cell, and noise-induced variation of all signal levels.
The Hadamard transform of this vector 634 is taken at 635, producing the result 636. It may be noted that the overall form of this result vector 636 is the same as that used to generate the numeric vector 630 used for storage; that is, a significantly positive value, followed by some arrangement of two significantly negative values 637 and five values near zero. These two values could be determined using circuitry that can detect the positions of the two smallest entries in the vector.
Further embodiments extend this concept to numeric vectors of the form (w, . . . ) where w is the weight of the vector, and “ . . . ” is a sequence of entries containing w values of −1 and the remainder values of 0. Such embodiments identify the w most negative values in the result vector after the Hadamard transform within the decoding process.
In the examples described herein, Hadamard matrices are used to form the basis for an encoder and decoder. In other embodiments, other orthogonal matrices might be used instead, however initial analysis may indicate that Hadamard matrices are preferred.
Hybrid Error Detection and Correction
The described methods may also be used in combination with known techniques for error correction and error identification, including single and multi-dimensional parity codes, low density parity codes, and forward error correction codes including Reed-Solomon, Golay, BCH, and Hamming code. These techniques, collectively called ECC, may be applied over blocks or words of data presented to the external interface of the storage subsystem, or to storage code groups written and read from sets of physical memory cells. One example embodiment computes ECC across seven bit storage code groups and stores the storage code groups with the computed ECC.
As has now been explained, systems and methods that combine Hadamard coding of storage formatted words with a dynamic memory storage array provide improved signal integrity and error reduction. The systems and methods are applicable to embodiments that are constrained by the planar area required for each capacitive component of the dynamic memory array, as the improved read detection ability can compensate for reduced cell capacitance, permitting significant array size reduction. Further embodiments are described that aggregate multiple instances of the described system and method into larger configurations, and which combine those methods with other error detection and error correction methods.

What is claimed is:
 
1. A method comprising:
selecting a plurality of storage cells based on a received read target address;
reading a plurality of charge levels of a storage format word from the selected plurality of storage cells;
generating elements of a results vector based on a weighted summation between a plurality of Walsh functions, each Walsh function weighted with a corresponding charge level, wherein each respective Walsh function represents a respective row of a Hadamard matrix, the respective row being (i) mutually orthogonal to all other rows of the Hadamard matrix and (ii) orthogonal to an all-one row of the Hadamard matrix;
generating elements of a numerical vector based on a maximal likelihood interpretation of the elements of the results vector; and
mapping the numerical vector to a set bits of a read data word.


  
2. The method of claim 1, wherein the read target address comprises a row selection element and a column selection element.

  
3. The method of claim 1, wherein a summation of the elements of the generated numerical vector is equal to 0.

  
4. The method of claim 3, wherein the numerical vector comprises a single element with a positive value with magnitude n, and n elements having a value of ‘−1’, wherein n is an integer greater than or equal to 1.

  
5. The method of claim 1, wherein the Hadamard matrix has size 2N, the storage format word comprises S=2N−1 elements, and wherein the read data word comprises B=N−1 bits, wherein N is an integer greater than or equal to 3.

  
6. The method of claim 1, further comprising generating an output data word by concatenating the set of bits of the read data word with a second set of bits of a second read data word.

  
7. The method of claim 6, wherein the second set of bits is generated based on a second results vector generated using the plurality of Walsh functions used to generate the results vector.

  
8. The method of claim 1, wherein the read data word is part of an error-correction code (ECC).

  
9. The method of claim 8, wherein the ECC is a code selected from the group consisting of: a Hamming code, a Reed-Solomon code, and a Golay code.

  
10. The method of claim 1, further comprising:
receiving a write data word;
mapping the write data word to components of a second storage format word;
determining a second selected subset of the plurality of storage cells according to an address input; and
storing the components of the second storage format word as charge levels on the second selected subset of the plurality of storage cells.


  
11. An apparatus comprising:
a dynamic memory read circuit configured to select a plurality of storage cells based on a received read target address, and to read a plurality of charge levels of a storage format word from the selected plurality of storage cells; and
a signal decoder configured to:
generate elements of a results vector by forming a weighted summation between a plurality of Walsh functions, each Walsh function weighted with a corresponding charge level, wherein each respective Walsh function represents a respective row of a Hadamard matrix, the respective row being (i) mutually orthogonal to all other rows of the Hadamard matrix and (ii) orthogonal to an all-one row of the Hadamard matrix;
generate elements of a numerical vector based on a maximal likelihood interpretation of the elements of the results vector; and
map the numerical vector to a set bits of a read data word.



  
12. The apparatus of claim 11, wherein the read target address comprises a row selection element and a column selection element.

  
13. The apparatus of claim 11, wherein a summation of the elements of the generated numerical vector is equal to 0.

  
14. The apparatus of claim 13, wherein the numerical vector comprises a single element with a positive value with magnitude n, and n elements having a value of ‘−1’, wherein n is an integer greater than or equal to 1.

  
15. The apparatus of claim 11, wherein the Hadamard matrix has size 2N, the storage format word comprises S=2N−1 elements, and wherein the read data word comprises B=N−1 bits, wherein N is an integer greater than or equal to 3.

  
16. The apparatus of claim 11, further comprising an aggregator configured to generate an output data word by concatenating the set of bits of the read data word with a second set of bits of a second read data word.

  
17. The apparatus of claim 16, wherein a second signal decoder is configured to generate the second set of bits based on a generated second results vector using the plurality of Walsh functions used by the signal decoder configured to generate the results vector.

  
18. The apparatus of claim 11, wherein the read data word is part of an error-correction code (ECC).

  
19. The apparatus of claim 18, wherein the ECC is a code selected from the group consisting of: a Hamming code, a Reed-Solomon code, and a Golay code.

  
20. The apparatus of claim 11, further comprising:
a signal encoder configured to:
receive a write data word; and
map the write data word to components of a second storage format word; and

a dynamic memory write circuit configured to:
determine a second selected subset of the plurality of storage cells according to an address input; and
store the components of the second storage format word as charge levels on the second selected subset of the plurality of storage cells.
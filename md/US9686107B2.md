Source: [US9686107B2](https://patents.google.com/patent/US9686107B2)

# [US9686107B2](US9686107B2.md) - Methods and systems for chip-to-chip communication with reduced simultaneous switching noise

## Details

* Date: 2010-05-20
* Inventor: Kandou Labs SA
* Beneficiary: John Fox, Brian Holden, Peter Hunt, John D. Keay, Amin Shokrollahi, Richard Simpson, Anant Singh, Andrew Kevin John Stewart, Giuseppe Surace

## Other patents

### Backwards
 * US3196351A
 * US3636463A
 * US3939468A
 * US4163258A
 * US4181967A
 * US4206316A
 * US4276543A
 * US4486739A
 * [US4499550A](US4499550A.md)
 * US4722084A
 * US4772845A
 * US4774498A
 * US4864303A
 * US4897657A
 * [US4974211A](US4974211A.md)
 * US5053974A
 * [US5166956A](US5166956A.md)
 * US5168509A
 * US5266907A
 * US5283761A
 * US5287305A
 * US5311516A
 * US5331320A
 * [US5412689A](US5412689A.md)
 * US5449895A
 * US5459465A
 * US5461379A
 * US5511119A
 * US5553097A
 * US5566193A
 * US5599550A
 * US5626651A
 * US5629651A
 * US5659353A
 * US5727006A
 * US5802356A
 * [US5825808A](US5825808A.md)
 * US5856935A
 * US5945935A
 * US5949060A
 * US5995016A
 * US5999016A
 * [US6005895A](US6005895A.md)
 * [US6084883A](US6084883A.md)
 * US6119263A
 * US6172634B1
 * US6175230B1
 * US6232908B1
 * [US6278740B1](US6278740B1.md)
 * US6316987B1
 * US6346907B1
 * US20020044316A1
 * US6378073B1
 * US20020057592A1
 * US6398359B1
 * US6404820B1
 * US6417737B1
 * US6433800B1
 * [US6452420B1](US6452420B1.md)
 * US20020154633A1
 * US6473877B1
 * US6509773B2
 * [US6556628B1](US6556628B1.md)
 * US20030086366A1
 * US6563382B1
 * JP2003163612A
 * US20030146783A1
 * US6621427B2
 * US6624699B2
 * US6650638B1
 * [US6661355B2](US6661355B2.md)
 * US6664355B2
 * [US6766342B2](US6766342B2.md)
 * [US6839429B1](US6839429B1.md)
 * US6839587B2
 * US6865234B1
 * US6865236B1
 * US6898724B2
 * US20050174841A1
 * US20050213686A1
 * [US6954492B1](US6954492B1.md)
 * US6973613B2
 * US6972701B2
 * US6976194B2
 * US6982954B2
 * [US6990138B2](US6990138B2.md)
 * [US6999516B1](US6999516B1.md)
 * US7039136B2
 * US7053802B2
 * US20060126751A1
 * US7085153B2
 * US7127003B2
 * [US7142612B2](US7142612B2.md)
 * US7167019B2
 * [US7180949B2](US7180949B2.md)
 * US7199728B2
 * US20070194848A1
 * US7269212B1
 * US20070265533A1
 * US20070263711A1
 * US20080007367A1
 * US20080013622A1
 * US7335976B2
 * US7339990B2
 * US7349484B2
 * US7356213B1
 * US7358869B1
 * US20080104374A1
 * US7372390B2
 * [US7389333B2](US7389333B2.md)
 * US20080159448A1
 * US7400276B1
 * US7428273B2
 * US7456778B2
 * US7462956B2
 * US20080317188A1
 * US7496162B2
 * US20090059782A1
 * EP2039221A1
 * US7535957B2
 * CN101478286A
 * WO2009084121A1
 * US7570704B2
 * US7599390B2
 * US20090251222A1
 * US7616075B2
 * US7620116B2
 * [US7633850B2](US7633850B2.md)
 * US7639596B2
 * US7643588B2
 * US20100023838A1
 * US7656321B2
 * US20100046644A1
 * WO2010031824A1
 * US7694204B2
 * US7697915B2
 * US7706524B2
 * US7706456B2
 * US7746764B2
 * US20100180143A1
 * US20100215112A1
 * US7787572B2
 * US7804361B2
 * US7808883B2
 * US20100296556A1
 * US7841909B2
 * US7869546B2
 * US7869497B2
 * US7882413B2
 * US7899653B2
 * US20110072330A1
 * US7933770B2
 * US20110150495A1
 * WO2011119359A2
 * US8030999B2
 * US8036300B2
 * US8050332B2
 * US8055095B2
 * US8064535B2
 * US20110291758A1
 * [US20110299555A1](US20110299555A1.md)
 * US8085172B2
 * US8091006B2
 * US20120008662A1
 * US8106806B2
 * US8149906B2
 * US8159375B2
 * [US8159376B2](US8159376B2.md)
 * US8180931B2
 * US8199849B2
 * US8199863B2
 * US20120152901A1
 * US8245094B2
 * US8253454B2
 * US8289914B2
 * US8310389B1
 * US20130010892A1
 * US8365035B2
 * US20130049863A1
 * US8406316B2
 * US8406315B2
 * US8429492B2
 * US8437440B1
 * US8451913B2
 * US8472513B2
 * US8498368B1
 * US20130195155A1
 * US8520348B2
 * US20130229294A1
 * US8539318B2
 * US8577284B2
 * US8578246B2
 * US8588254B2
 * US8620166B2
 * US8638241B2
 * US8649460B2
 * US8649445B2
 * US8711919B2
 * US8755426B1
 * US8773964B2
 * US8780687B2
 * US20140198841A1
 * US20140226455A1
 * US8831440B2
 * US8879660B1
 * US8897134B2
 * US8949693B2
 * US8951072B2
 * US8975948B2
 * US20150078479A1
 * US9020049B2
 * US9036764B1
 * US9069995B1
 * US9077386B1
 * US9083576B1
 * US9093791B2
 * US9100232B1
 * US9124557B2
 * US9152495B2
 * US9172412B2
 * US9183085B1
 * US20150333940A1
 * US9197470B2
 * US20150381232A1
 * US20160020796A1
 * US20160020824A1
 * US20160036616A1
 * US9281785B2
 * US9288089B2
 * [US9288082B1](US9288082B1.md)
 * US9292716B2
 * US9306621B2
 * US9331962B2
 * US9362974B2
 * US9363114B2
 * US9374250B1
 * US9432298B1
### Forward
 * US10560116B2
## Abstract

Abstract

Systems and methods are described for transmitting data over physical channels to provide a high speed, low latency interface such as between a memory controller and memory devices with significantly reduced or eliminated Simultaneous Switching Output noise. Controller-side and memory-side embodiments of such channel interfaces are disclosed which do not require additional pin count or data transfer cycles, have low power utilization, and introduce minimal additional latency. In some embodiments of the invention, three or more voltage levels are used for signaling.



Systems and methods are described for transmitting data over physical channels to provide a high speed, low latency interface such as between a memory controller and memory devices with significantly reduced or eliminated Simultaneous Switching Output noise. Controller-side and memory-side embodiments of such channel interfaces are disclosed which do not require additional pin count or data transfer cycles, have low power utilization, and introduce minimal additional latency. In some embodiments of the invention, three or more voltage levels are used for signaling.

CROSS REFERENCE TO RELATED APPLICATIONS
This application is a continuation of U.S. application Ser. No. 14/842,511, filed Sep. 1, 2015, entitled “Methods and Systems for Chip-to-Chip Communication with Reduced Simultaneous Switching Noise,” which is a continuation of U.S. application Ser. No. 14/158,452, filed Jan. 17, 2014, entitled “Methods and Systems for Chip-to-Chip Communication with Reduced Simultaneous Switching Noise, which is a non-provisional application claiming priority to U.S. provisional application No. 61/753,870 filed on Jan. 17, 2013, all of which are hereby incorporated herein by reference in their entirety for all purposes.
The following references are herein incorporated by reference in their entirety for all purposes:
U.S. Patent Publication 2011/0268225 of U.S. patent application Ser. No. 12/784,414, filed May 20, 2010, naming Harm Cronie and Amin Shokrollahi, entitled “Orthogonal Differential Vector Signaling” (hereinafter “Cronie I”);
U.S. Patent Publication 2011/0302478 of U.S. patent application Ser. No. 12/982,777, filed Dec. 30, 2010, naming Harm Cronie and Amin Shokrollahi, entitled “Power and Pin Efficient Chip-to-Chip Communications with Common-Mode Resilience and SSO Resilience” (hereinafter “Cronie II”);
U.S. patent application Ser. No. 13/030,027, filed Feb. 17, 2011, naming Harm Cronie, Amin Shokrollahi and Armin Tajalli, entitled “Methods and Systems for Noise Resilient, Pin-Efficient and Low Power Communications with Sparse Signaling Codes” (hereinafter “Cronie III”); and
U.S. patent application Ser. No. 13/463,742, filed May 3, 2012, naming Harm Cronie and Amin Shokrollahi, entitled “Finite State Encoders and Decoders for Vector Signaling Codes” (hereafter called “Cronie IV”).
U.S. patent application Ser. No. 13/603,107, filed Sep. 9, 2012, naming Brian Holden and Amin Shokrollahi, entitled “Methods and Systems for Selection of Unions of Vector Signaling Codes for Power and Pin Efficient Chip-To-Chip Communication” (hereinafter called “Holden I”).
U.S. patent application Ser. No. 13/671,426, filed Nov. 7, 2012, naming Brian Holden and Amin Shokrollahi, entitled “Crossbar Switch Decoder for Vector Signaling Codes” (hereinafter called “Holden II”).
BACKGROUND
In communication systems, information may be transmitted from one physical location to another. Furthermore, it is typically desirable that the transport of this information is reliable, is fast and consumes a minimal amount of resources.
Vector signaling is a method of signaling. With vector signaling, pluralities of signals on a plurality of wires are considered collectively although each of the plurality of signals may be independent. Each of the collective signals is referred to as a component and the number of plurality of wires is referred to as the “dimension” of the vector. In some embodiments, the signal on one wire is entirely dependent on the signal on another wire, as is the case with differential signaling pairs, so in some cases the dimension of the vector may refer to the number of degrees of freedom of signals on the plurality of wires instead of the number of wires in the plurality of wires.
With binary vector signaling, each component takes on a coordinate value (or “coordinate”, for short) that is one of two possible values. As an example, eight single ended signaling wires may be considered collectively, with each component/wire taking on one of two values each signal period. A “code word” of this binary vector signaling is one of the possible states of that collective set of components/wires. A “vector signaling code” or “vector signaling vector set” is the collection of valid possible code words for a given vector signaling encoding scheme. A “binary vector signaling code” refers to a mapping and/or set of rules to map information bits to binary vectors.
With non-binary vector signaling, each component has a coordinate value that is a selection from a set of more than two possible values. A “non-binary vector signaling code” refers to a mapping and/or set of rules to map information bits to non-binary vectors.
Examples of vector signaling methods are described in Cronie I, Cronie II, Cronie III, and Cronie IV.
Signaling using a plurality of wires that change state simultaneously may be associated with undesirable secondary effects within the output circuit, due to the physical need to change the output level on multiple wire loads. The resulting anomalous noise, caused by this current draw from power sources and/or current drain into ground lines and/or power returns, is known as Simultaneous Switched Output noise or SSO.
BRIEF SUMMARY
In accordance with at least one embodiment of the invention, processes and apparatuses provide for transmitting data over physical channels to provide a high speed, low latency interface with no or reduced Simultaneous Switching Output noise as compared to single-ended interfaces using the same physical pin count.
One example embodiment of the invention describes a channel interface between a memory controller and one or more memory devices, which must deliver at least the same throughput as a single-ended solution with significantly less SSO and reduced power utilization, without requiring additional pin count or significantly increased transfer latency. Controller-side and memory-side embodiments of such channel interfaces are disclosed. In some embodiments of the invention, different voltage, current, etc. levels are used for signaling and more than two levels may be used, such as a vector signaling code wherein each wire signal may take on any of three, four, or more values.
This Brief Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Brief Summary is not intended to identify key or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter. Other objects and/or advantages of the present invention will be apparent to one of ordinary skill in the art upon review of the Detailed Description and the included drawings.

BRIEF DESCRIPTION OF THE DRAWINGS
Various embodiments in accordance with the present disclosure will be described with reference to the drawings. Same numbers are used throughout the disclosure and figures to reference like components and features.
 FIGS. 1A and 1B show block diagrams for a conventional single-ended multiwire interface, and a vector signaling coded interface in accordance with at least one embodiment of the invention.
 FIGS. 2A and 2B show circuit examples of a multi-level output driver and a multi-level input receiver, in accordance with at least one embodiment of the invention.
 FIG. 3 is a block diagram of an optimized receiver for the P2P code, in accordance with at least one embodiment of the invention.
 FIG. 4 is a block diagram of an optimized receiver for either the P4P or H4P code, in accordance with at least one embodiment of the invention.
 FIGS. 5A and 5B are block diagrams of an optimized receiver for the 4b4wT code, in accordance with at least one embodiment of the invention.
 FIG. 6 is a block diagram of an optimized receiver for the 4b4wQ code, in accordance with at least one embodiment of the invention.
 FIG. 7 is a block diagram of an optimized receiver for the 2b2wT code, in accordance with at least one embodiment of the invention.
 FIGS. 8A and 8B are charts summarizing and comparing the vector signaling code embodiments described herein in accordance with the invention.
 FIGS. 9A and 9B show block diagrams for a conventional single-ended multiwire interface, and a TL3 coded interface in accordance with at least one embodiment of the invention.

DETAILED DESCRIPTION
Specialized memory subsystems of modern computer systems utilize dedicated memory controllers to manage access, optimize performance, and improve utilization and reliability. Interconnections between these memory controllers and memory devices must operate at high speeds, delivering reliable and low latency data transfers, while under significant constraints in terms of available pin count and power utilization. To maximize data transfer throughput and efficiency, extremely wide data transfer operations are the norm, typically of 128 bits or more per cycle, as shown in the block diagram of FIG. 1A. These wide I/O transfers put considerable strain on output driver power utilization, especially when many bits change state simultaneously. Such Simultaneous Switched Output transitions may draw significant power supply current and/or introduce considerable return current into the ground line, significantly raising the system noise level.
Methods of addressing Simultaneous Switched Output noise are known, generally operating by reducing the number of wires allowed to change simultaneously by spreading the state change over multiple clock cycles, or by selective inversion of sets of wires as indicated by additional interface signals. However, devices relying on standardized physical interface specifications do not have the liberty of introducing additional interface signals, or of extending data transfer operations over a longer period of time.
Moreover, the design of interfaces to such interconnections is further constrained by implementation requirements, as controller devices are typically implemented using high speed logic processes, while memory devices such as DRAM rely on specialized processes optimized for high storage density and low leakage, but possibly not for fast logic speed. Thus, a successful memory-to-controller interconnection architecture must support implementation in these multiple semiconductor processes.
In accordance with at least one embodiment of the invention, several classes of SSO reducing and SSO eliminating codes are presented, their properties investigated, and example embodiments of encoders and decoders described.
The described solutions all meet the goals:
    Implementable in both high-speed logic and DRAM processes Consume very low power for the encoder, driver, receiver, and decoder Reduce (or entirely eliminate) SSO when compared to single ended signaling Applicable to wide I/O interconnections (128 to 1024 wires)   
A number of SSO reducing and SSO eliminating codes are described, for which the encoder and decoder have very small footprint. In applications of primary interest to this document the communication channel between the sender and the receiver has very low insertion loss, and therefore hardly experiences noise caused by ISI, insertion loss, reference noise, or thermal noise. On the other hand, SSO causes a large amount of noise because of the relatively large size of the bus. We therefore trade off immunity to common mode and reference noise in some of our examples to further reduce the size and hence the power consumption of the encoding and decoding circuitry needed for our system.
General Assumptions
For purposes of comparison and without limitation, a reference interface design is assumed to use single-ended CMOS drivers to drive extremely short non-terminated bussed or point-to-point interconnections. Inter-symbol interference and transmission line loss are considered to be small or negligible for the example use, and reference noise and thermal noise are considered to be tractable.
Similarly, for purposes of description and without limitation, examples describing a particular physical interface width will assume data transfer occurs over 128 signal wires or pins, although the described solutions may be equally well applied to both narrower and wider interfaces. The various examples presented herein utilize group or ensemble encoding of subsets of that physical interface, also known as a vector signaling code, as examples in sets of 3 or 4 wires as shown in FIG. 1B. Thus, a physical interface of 128 wires would utilize 43 or 32 instances of the described embodiment, respectively. Embodiments based on group encoding using larger sets of wires are also described, along with the engineering trade-offs associated with selection of set size.
Each described embodiment of the invention offers different degrees of SSO reduction and/or power consumption, and some allow trading off immunity to common mode and reference noise in favor of reduced implementation size and required power consumption.
In accordance with at least one embodiment of the invention, signaling using three or more distinct signal levels may be used. As one example, an output driver for a three level or ternary signaling method is shown in the circuit diagram of FIG. 2A, with a complimentary ternary input receiver. Further embodiments using four level or quaternary signaling methods are also described, incorporating additional voltage levels and transmission gates into the example driver, and additional input comparison or detection transistors into the example receiver. Based on these examples, a knowledgeable practitioner may extend the described concepts to more than 3 or 4 signal levels per wire.
Ternary Levels
In accordance with at least one embodiment of the invention, three distinct output levels may be transmitted on every transmission wire, in a “ternary coding” scheme. The coordinate levels of the ternary code correspond to voltage levels on the wires, which in turn depends on the Vdd of the system and the swing of the signals. To permit a voltage-independent description allowing fair comparison to single-ended signaling, the descriptions assume that:
    For full-swing Single-Ended (SE) binary signaling, the voltage level multipliers are 0 and 1 (i.e., the voltage levels correspond to 0*Vdd (which is typically equal to Vss) and 1*Vdd) For Full-Swing (FS) ternary coding, the voltage level multipliers are 0, ½, and 1. For Reduced-Swing (RS) ternary coding, the voltage level multipliers are 0, ¼, and ½.   
For each described coding schemes, we will compare the performance against that of single-ended signaling. Both SSO and power consumption will be described by a single number. For the power consumption, this number has to be compared against ¼, which is the average per wire power consumption of single-ended signaling. For the worst case SSO, our numbers are to be compared against 1, which is the worst case SSO of single-ended signaling.
The multipliers used as examples are taken for purposes of descriptive clarity. Some embodiments of the invention may rely on other multiplier factors of Vdd or equivalent absolute signal levels satisfying the same signal identification purpose. As examples, one embodiment of reduced swing ternary signaling may use coordinates of ¼ Vdd, ½ Vdd, ¾ Vdd, and another embodiment may use coordinates of 0 V, 300 mV, and 600 mV, each representing three distinct coordinate values spanning a range less than that of a full-swing CMOS binary signal.
Similarly, embodiments utilizing quaternary or higher-ordered signaling may define four (or more) levels extending across the entire Vdd to Vss span to create a full-swing signaling scheme, or may define such levels contained within a smaller overall span, creating a reduced-swing signaling scheme.
Line States
For simplicity in the description of coding algorithms later in the document, the two binary states are designated 0 & 1 and the three ternary states as 0, 1, & 2. Similarly, quaternary states are described as 0, 1, 2, & 3. These states are independent of the voltage level multipliers described above that are used to transmit them.
Driver Power Consumption
In the case of a non-terminated CMOS driver, the main power drawn from the Vdd or positive supply rail is consumed in changing the voltage on the primarily capacitive load of the output line when the driver makes a transition from a lower state to a higher state. For a given load, the amount of consumed power is proportional to the magnitude of the transition. Stated differently, when transitioning from a state (x1, . . . , xk) to a following state (y1, . . . , yk) the driver power on k wires is proportional to the sum max(x1−y1, 0)+ . . . +max(xk−yk,0). This is independent of the particular reference chosen since the reference is canceled by taking differences. The power consumed by single-ended signals on k wires is between 0 and k, and the average power is k/4 since on a single wire a power consumption of 1 occurs only when transitioning from a 0 to a 1.
A similar calculation may be made to assess the power dissipated (or alternatively, the current injected into the Vss or ground rail) in changing the voltage on the primarily capacitive load of the output line when the driver makes a transition from a higher state to a lower state. In some embodiments, this flow of Vss or ground current may be as significant a design factor as the current drawn from the Vdd or supply rail.
Additional Driver Considerations
A conventional embodiment of a binary output driver is based on a CMOS inverter structure, where a totem pole pair of transistors is used to source current from the Vdd or positive supply rail to the output pin, or conversely sink current from the output pin to the Vss or ground rail. Use of dedicated output driver power rails is known, either for purposes of noise isolation, or to allow the I/O to operate at different or distinct voltage levels compared to the main logic and/or memory systems. Cascaded chains of inverters are commonly used, with the transistors at each stage being scaled up in size and current capability from the extremely low node capacitance and current demands of an internal circuit node, to the relatively massive capacitance and proportionately large current demands of the actual output pin and external load.
In accordance with at least one embodiment of the invention, output drivers for ternary or higher-ordered output levels add additional intermediate voltage elements to the binary driver's single source and single sink transistor. Such intermediary-level outputs may be based on CMOS transmission gate structures connecting an intermediate voltage rail to the output pin, or may alternatively use a single transistor in a source follower topology from such an intermediate voltage rail. There may also be advantages in generating not only intermediary-level outputs but also one or both extreme output levels using such techniques, for example to reduce overall output level swing to less than Vdd−Vss.
Intermediate voltage levels may be generated on-chip, or may be provided from an external source to multiple chips. It should be noted that linear regulator designs such as commonly used to regulate on-chip voltages represent current loads on their supply rail equal to the output current delivered. That is, linear regulation of, as an example, Vdd 1.8 volts to 0.8 volts at a load of 10 ma, will draw the same 10 ma from Vdd, dissipating 10 mw in the series pass transistor. Conversely, an external switching regulator which can incorporate discrete inductors and capacitors might draw merely 5.6 ma from a 1.8 volt supply, converting that power to 0.8 volts at 10 ma with 80% efficiency. Thus, the power dissipation advantages of codes incorporating additional output levels and/or smaller output level swings may be in some part mitigated by the inefficiencies of any associated on-chip voltage regulators.
In some embodiments, the number and magnitude of allowable signal levels may be constrained by driver characteristics. As one example, transistors in some DRAM processes are characterized by rather high Vt values, which may result in relatively low gate overdrive with some combinations of desired output signal value and available voltage rail value.
SSO Noise
The main SSO is caused by transitions between states. The SSO noise value may be normalized to a single number in the following sense: for the SSO on k wires, the SSO caused by the transition from a state (x1, . . . , xk) on the wires to a state (y1, . . . , yk) is set to be equal to |(x1−y1)+ . . . +(xk−yk)| which in turn is equal to the absolute value of the sum of the coordinates of x minus the sum of the coordinates of y. Because a common reference is canceled through taking the difference, the SSO is independent of the reference.
For a single-ended binary system the SSO produced on 1 wire is either 0 or 1. When taking k wires, the worst case SSO is k, and it can be any number between 0 and k. Simple coding can reduce this number considerably, and even completely reducing it to zero in certain cases.
For single-ended binary signaling on k wires, the power consumption of every transition has a binomial distribution on 0, . . . , k where the probability of a single event is 1/4, and its average is k/4. The SSO of this signaling is also binomially distributed and the worst case SSO is k.
Receiver Power Consumption
In many embodiments, the primary source of static power consumption within the receiver is the differential line receiver or signal level comparator stage derived from a linear differential amplifier topology. Thus, embodiments requiring additional comparators, such as to distinguish multiple signal levels per wire, may be associated with higher static receive current usage. In some embodiments, these factors may be mitigated by gating or disabling comparator power when not required, and/or by using a dynamic rather than static design for the comparator stage.
Single-Ended Signaling Code on 4 Wires
Single-ended signaling on 4 wires is the straightforward generalization of normal single-ended signaling to 4 wires, i.e., each wire is independently running single-ended signaling. This corresponds to a code, albeit a very simple code: the elements transmitted on the 4 wires are all the 16 vectors of 4 bits (a,b,c,d):
  (0,0,0,0), (0,0,0,1), (0,0,1,0), (0,0,1,1), (0,1,0,0), (0,1,0,1), (0,1,1,0), (0,1,1,1) (1,0,0,0), (1,0,0,1), (1,0,1,0), (1,0,1,1), (1,1,0,0), (1,1,0,1), (1,1,1,0), (1,1,1,1)

Power Consumption and SSO
 
It is obvious that the average power consumption of this scheme on the 4 wires is 1: this is because the average power consumption as previously defined per wire is 0.25; this follows from the fact that out of the 4 transitions 0 to 0, 0 to 1, 1 to 0, and 1 to 1 only the transition 0 to 1 costs 1 unit of power and the others cost 0 units of power. Since all transitions are equally likely, the average per wire power consumption is 0.25, and hence the average power consumption on 4 wires is 4×0.25=1. The worst case per-wire power consumption is 1, and hence the worst case power consumption for the 4 wires is 4. The worst case SSO for this scheme is 4 for the 4 wires, and hence the worst-case per-wire SSO is 1. The worst case power consumption on an interface with 128 wires is 128 units, the average power consumption is 32 units, and the standard deviation from the average (assuming uniformly random input) is 27.71.
Encoding and Decoding
There is no real encoding and decoding for this code; these operations are performed by the driver and by the receiver directly outputting and directly inputting binary values to the interconnection wires. The receiver samples the wire and measures the value against ½. If the value is below ½, then a decision is made in favor of the value 0, otherwise the decision is made in favor of the value 1.
SNR of Decoder with Respect to Thermal Noise
We assume that the wires are independently perturbed by additive white Gaussian noise of mean 0 and variance σ2. We are interested in the probability that there is at least one bit in a group of 4 that is in error. Because of independence of the noise on the wires, this probability is equal to
         1 -   (  1 -   1 2  ⁢  erfc ⁡  (  1  2 ⁢  2  ⁢ σ   )     )  4   ≈  2 ⁢     ⁢  erfc ⁡  (  1  2 ⁢  2  ⁢ σ   )     ,     [  Eqn .     ⁢ 1  ]       
where

     erfc ⁡  ( x )   =  1 -   1  π   ⁢   ∫ 0 x  ⁢   ⅇ  -  t 2    ⁢     ⁢  ⅆ t         
is the complementary error function. We would like to calculate the value of σ for which this error probability is equal to 1e-15; if we write this value of σ in the form σ=10−s/20, then s is the SNR in dB. So we would like to calculate the SNR for which the error probability is equal to 1e-15. A numerical calculation reveals the following value for the SNR of this scheme to be SNR≈24.1 dB.

TL3 Transition-Limiting Coding

Because it is the transitions that are important in an un-terminated CMOS driver, it makes sense to encode the information in the transitions. If we use binary states on the wires then it is not possible to reduce SSO and at the same time maintain full pin-efficiency, i.e., the property of transmitting one bit per clock cycle on every wire. Therefore, some described method of reducing the SSO uses ternary signaling and transition-limiting coding.
TL3 is one such code that reduces the peak SSO to just 33% of single ended.
In accordance with at least one embodiment of the invention, a mod-3 addition method may be used to encode binary data into TL3. This operation adds one of the three integers 0/1/2 with another such integer, and outputs the remainder of this addition when divided by the number 3, as shown by the table:



 
 
 
 
 
 
 
 
 
 
 
0
1
2
 
 
0
0
1
2
 
 
1
1
2
0
 
 
2
2
0
1
 
 
 
 







TL3 coding operates on an interface size of three wires, i.e., a group of three wires is used on which the state transitions between the clock cycles are minimized. One example embodiment of this invention utilizes the combination of a ternary code and a simple FIR filter. This FIR filter keeps one clock of history and encodes the new information as changes with respect to that history. Other embodiments of self-synchronizing state transition determination are known, and are equivalent. An efficient encoder uses only a few operations on the state of each wire.
In the reduced swing version of TL3 (TL3-RS), the peak per-wire SSO is 1/6, which is less than 17% of the peak per-wire SSO of single-ended signaling. For full-swing TL3 (TL3-FS), the peak per-wire SSO is 1/3, which is less than 34% of the peak per-wire SSO of single-ended signaling.
The average line power consumption of TL3-RS encoded signaling is about 20.6% of the average line power consumption of single-ended signaling. The average line power consumption of TL3-FS encoded signaling is about 41.1% of the average line power consumption of single-ended signaling.
In this and other examples, if the total number of wires is not divisible by the interface size, the interface is designed to have the remaining lines operate in pass-through mode with the same delay as in normal operation.
 FIGS. 9A and 9B provide block diagrams comparing a three wire subset of a regular wide I/O interface between a transmitting chip and a receiving chip, and a three wire subset of a comparable interface using a TL3 code. As described earlier, the actual signal levels used to represent the three ternary coordinate values is independent of the TL3 coding/decoding, thus FIGS. 9A and 9B illustrate both TL3-FS and TL3-RS variants.
In the TL3 interface illustrated in FIGS. 9A and 9B, the embodiment of the history-storing element within the transmitter is shown as comprising three of the six total flip-flops following the transition-limited encoder. Other embodiments may organize the elements in a different order providing equivalent behavior.
The receiver front end for the ternary codes used by TL3 require two comparators per wire and two reference levels, typically at the midpoints between the 0,1 and 1,2 signal levels. The history-storing element within the receiver is shown as comprising a set of six history flip-flops operating in parallel with the main data flow from ternary receiver to line flip-flops to transition limited decoder. Other embodiments may organize the required elements in a different order providing equivalent behavior, for example, placing the decoder immediately after the ternary receivers.
Reduction of Overall Signal Swing
In accordance with at least one embodiment of the invention, the selected code may be combined with reduced signal swings to provided additional SSO reduction over the reference full-swing binary CMOS example. As one particular example, the described TL3 code may be combined with the previously described RS signal levels, to produce the TL3-RS signaling method. Other such combinations of coding and signal swing constraint are described explicitly below, or otherwise should be considered as implicitly included combinations of the described elements.
Other Variants of the Transition Limiting Code
Other, more efficient variants of the TL3 coding described above exist as well. In one embodiment in accordance with the invention, the interface size is chosen to be 4. A compact code for this case that is similar to the one used for TL3 is called Transition Limiting 4-wire simple or TL4s. Another variant exists with a somewhat larger encoder and decoder called Transition Limiting 4-wire enhanced or TL4e coding. For these two interfaces:
    TL4s-RS has a peak SSO of 18.75% of SE. TL4e-RS has a peak SSO of 12.5% that of SE.   
For each of these, the average line power consumption is slightly better than their TL3 full and reduced swing equivalents.
For two other variants, the interface size can be chosen to be equal to either 5 or 8 wires. In these two cases, the simple version of each encoder has performance similar to the enhanced version of the 4 wire interface. Enhanced versions of each of these variants also exist. For the simple versions of these two interface:
    TL5s-RS has a peak SSO of 15% of SE. TL8s-RS has a peak SSO of 12.5% of SE.   
In all these listed cases the wires are in one of three states, i.e., the codes are ternary. Using quaternary coding (i.e., coding with 4 levels), more advantages can be gained at the expense of more complicated circuitry for the drivers and more comparators at the receiver. For example, using quaternary coding and a 4-wire interface, the peak SSO is always reduced to 25% of that of single-ended signaling, and the average power consumption is reduced further.
Reset of the Transition Code
Two additional related issues exist with the use of transition codes. The first issue is ensuring that the history values used at each end are coordinated when the bus is used sporadically. The second issue, discussed in the next section, is ensuring that transitions on the line are minimized when the bus is not in use.
The first issue is to ensure that the history values at each end of the bus are using the same value. For buses that are running continuously, this is not an issue because the history values are set after a single clock. For buses such as bidirectional data buses, which are used sporadically by different transmit-receive pairs, and which produce data in narrow intervals, a reset function can also be used to coordinate the value of the history function.
When a data bus is not in use, the history value in the FIR filter at each end is reset to a known value. When that data bus is used, the reset is released at the exact moment that the data becomes valid.
In applications where an address bus is encoded with the TL3 code, two options are possible. The first option is to reset the history value when the address bus is not in use. The second option is to simply allow the address bus to run for a single clock at startup.
Control of the Idle Values
The second issue with the use of transition codes is to carefully control the idle values on the bus. Since one advantage of using a transition code is to minimize the transition on the bus, it may be desirable to ensure that there are no transitions on the bus when the bus is not in use. Many buses sit idle most of the time, so the power dissipated in these situations is central to the overall power consumption of the system.
With transition codes, only a single specific value of the bus leads to no transitions on the bus. This is not an issue with data buses since they are held in reset as described above. Three options exist for address and control buses.
The first option for address and control buses is to organize the interface between the controller and the physical bus, so that during idle periods the address or control bus produces the particular value that is encoded as no transition.
The second option is to hold the address and control in reset when not in use, similar what is done for the address bus.
The third option is to add a bus-holder circuit to the bus interface which has extra flip flops at the transmit end to detect whether the bus has the same value as during the previous clock. The encoder then communicates that information via an additional special code word to the far end. Both the TL3 and TL4 codes could encode such a 9th or 17th state.
Enhanced TL4 SSO-Reducing Code
In accordance with at least one embodiment of the invention, this variation of the previously described modulus-encoded code called TL4 encodes four bits of data as ternary signals on four wires. This enhanced encoder never uses any of the sixteen code words that have only extreme values such as 2,2,2,0. There are 65 others that don't have that property. The states that have 4 extreme values only have 15 possible destinations, so they can't encode 4 bits. However, the other states all can do it. The ones with 3 extreme values have 17 destinations, and the others are even better.
TL4 Encoding
The task of the encoder is to calculate a codeword upon receiving 4 bits (a,b,c,d). The encoder may either maintain additional state which describes the index of one wire in the previous state that is 1 (a neutral state), say q, and a vector describing the indices of the other positions, say p[0], p[1], p[2] or, alternatively, may compute the additional state on the fly. If the 4 incoming bits correspond to the integer n, then we do the following; h(x) is defined as h(−1)=h(1)=0 and h(0)=1. —If n=0, then do nothing—If n=1 then change wire with index p[0] by +1—If n=2 then change wire with index p[1] by +1—If n=3 then change wire with index p[2] by +1—If n=4 then change wire with index p[0] by −1—If n=5 then change wire with index p[1] by −1—If n=6 then change wire with index p[2] by −1—If n=7 then change wires with indices p[0] by h(p[0]) and p[1] by h(p[1])—If n=8 then change wires with indices p[0] by h(p[0]) and p[2] by h(p[2])—If n=9 then change wires with indices p[1] by h(p[1]) and p[2] by h(p[2])—If n=10 then change wire with index q by −1 and wire with index p[0] by h(p[0])—If n=11 then change wire with index q by −1 and wire with index p[1] by h(p[1])—If n=12 then change wire with index q by −1 and wire with index p[2] by h(p[2])—If n=13 then change wire with index q by +1 and wire with index p[0] by h(p[0])—If n=14 then change wire with index q by +1 and wire with index p[1] by h(p[1])—If n=15 then change wire with index q by +1 and wire with index p[2] by h(p[2]) In addition to these, the indices q and p[0], p[1], p[2] need to be updated as well. For example, in cases n=0, . . . , 9, q does not have to be changed and hence the vector p can remain as it is as well. For the other cases q definitely changes. It is not necessary to have 16 cases around; one can find shortcuts. For example, the cases n=1, 2, 3 are similar and can be handled in a better way.
In further embodiments, the encoding algorithms may use the following two tables:



 
 
 
 
T1 
 
 
 
 
 
 
 
 
 
 
 
 
0
1
 
 
0
1
2
 
 
1
2
0
 
 
2
0
1
 
 
 
 












 
 
 
 
T2 
 
 
 
 
 
 
 
 
 
 
0
1
 
 
1
0
 
 
2
1
 
 
 
 









Encoding for TL3: Given three bits (a, b, c), and a prior state (p[0], p[1], p[2]), we would like to calculate uniquely a successor state that replaces the prior state. This is done according to the following algorithm in which the “idle” state corresponds to the bit sequence [1, 1, 1].



 
 
 
 
Algorithm 1 Encoding for TL3
 
 
 
 
 
 
 
Input: Bits a, b, c, prior state p = (p[0], p[1], p[2]) of the three wires 
 
where p[i] ε {0, 1,2}
 
Output: p changes to its successor state, uniquely determined by a, b, c.
 
1: if bc = 0 then
 
2:  p[b + 2c] ← T1 (p[b + 2c], a)
 
3: else
 
4:  if a = 0 then
 
5:   p[0]← T2 (p[0]) 
 
6:   p[1]← T2 (p[1]) 
 
7:  end if
 
8: end if
 
 
 









Therefore, in one embodiment, the encoder receives three input bits (a,b,c). A first logic gate circuit determines if a first two bits (c, b) of the three input bits are not both ones, and if so then a selection circuit utilizes those first two bits to determine which output wire (by determining an index value b+2c) will change states. The encoder receives the prior state of that wire from a state memory circuit (such as by flip-flop storage elements) and in combination with the third input bit, determines the new state (e.g., according to a logic lookup function equivalent to table T1) for the determined wire. In the event that the first two input bits are both ones, the output of the first logic gate circuit in conjunction with the third data bit (a) selectively enables (e.g., when a=0) a lookup circuit that implements the lookup function of table T2 and uses results to determine the new states for the first two wires. For example, the successor state of [0, 2, 1] under [0, 1, 1] is [1, 1, 1] (because cb=1, and a=0, both p[0] and p[1] are modified according to T2, where p[0]=0 changes to 2, and p[1]=2 changes to 1) and the successor state of [0, 2, 1] under [0, 0, 1] is [0, 2, 2] (because cb=0, b+2c=2, and a=0, so p[2]=1 changes to 2 according to T1. One of skill in the art will recognize that Boolean operations may be performed on the above relationships to yield equivalent expressions.
Not all the states are equiprobable in this scheme, even if the bits a, b, c are chosen uniformly and independently at random. The stationary probability distribution on the states is given by the vector:
    13/315, 59/1260, 1/35, 59/1260, 1/18, 13/420, 1/35, 13/420, 1/42, 13/315, 59/1260, 1/35, 59/1260, 1/18, 13/420, 1/35, 13/420, 1/42, 13/315, 59/1260, 1/35, 59/1260, 1/18, 13/420, 1/35, 13/420, 1/42.   
The ith entry of this vector corresponds to the probability of the state given as the 3-adic expansion of i−1. Hence, 13/315 is the probability of seeing the state [0, 0, 0], 59/1260 is the probability of seeing the state [1, 0, 0], etc.
Average power consumption. We assume that for a, b ε {0, 1, 2} a transition a→b requires power proportional to max(b−a, 0)−c min(b−a, 0), wherein c is any constant of our choosing. It turns out that the average power consumption relative to that of single-ended signaling is independent of c. With this assumption, the average power consumption of single-ended signaling is (1+c)/4: transitions 0→0 and 1→1 require no power, transition 0→1 requires one unit, and transition 1→0 requires c units.
In the case of the TL3 code, a calculation shows that the average power consumption per wire is (1+c)×37/360. The average power consumption of the TL3 code divided by the average power consumption of single-ended signaling is therefore 37/90 which is roughly 0.411.
Decoding for TL3. The task of the decoder is to infer from a previous state p=(p[0], p[1], p[2]) and a successor state s=(s[0], s[1], s[2]) the bits a, b, c.



 
 
 
 
Algorithm 2 Decoding for TL3
 
 
 
 
 
 
 
Input: Prior state p = (p[0], p[1], p[2]) and successor state s = (s[0],
 
 s[1], s[2]) on the three wires, where p[i], s[i] ε {0, 1, 2}
 
Output: Bits a, b, c
 
 1: a ← 1, b ← 1, c ← 1
 
 2: Calculate w = (s − p) mod 3
 
 3: Determine weight of w, and call it m
 
 4: Determine position a0 + 2b0 such that w[a0 + 2b0] /=
 
0, t ← w[a0 + 2b0]
 
 5: if m = 1 then
 
 6:  b ← a0, c ← b0, a ← t − 1
 
 7: else
 
 8:  b ← 1, c ← 1
 
 9:  if m = 2 then
 
10:   a ← 0
 
11:  end if
 
12: end if
 
 
 









Encoding for TL4. Given four bits (a, b, c, d), and a prior state (p[0], p[1], p[2], p[3]), we would like to calculate uniquely a successor state which replaces the prior state. This is done according to the following algorithm in which the “idle” state corresponds to the bit sequence [1, 1, 1, 1,]. For example, the successor state of [0, 2, 1, 2,] under inputs [1, 0, 1, 1,] is [0, 2, 0, 1,]. Not all the states are equiprobable in this scheme, even if the bits a, b, c, d are chosen uniformly and independently at random.
Average power consumption. A calculation shows that the average power consumption per wire is 1247/10560. The average power consumption of the TL4 code divided by the average power consumption of single-ended signaling is therefore (10/3)×1247/10560)=1247/3168 which is roughly 0.394. This number is independent of how we model the power consumption at transitions. In fact, if we weight downward transitions by a factor of c, and upward transitions by a factor of 1, then the average power consumption of single-ended signaling becomes (1+c)/4, whereas the average power consumption of the TL4 code becomes (1+c)×1247/12672. The ratio remains the same, irrespective of c.



 
 
 
 
Algorithm 3 Encoding for TL4
 
 
 
 
 
 
 
Input: Bits a, b, c, d, prior state p = (p[0], p[1], p[2], p[3]) of the four wires
 
Output: p changes to its successor state, uniquely determined by a, b, c, d.
 
 1: if d = 0 then
 
 2:  p[a + 2b] ← T1 (p[a + 2b], c)
 
 3: else
 
 4:   if bc = 0 then
 
 5:   p[ac + 2ac] ← T2 (p[ac + 2ac])
 
 6:   p[bc|c + 2āc] ← T2 (p[bc|c + 2āc])
 
 7:   else
 
 8:    if a = 0 then
 
 9:    p[0] ← T2 (p[0], p[1] ← T2 (p[1]), p[2] ← T2 (p[2])
 
10:    end if
 
11:   end if
 
12: end if
 
 
 









Thus, in one embodiment, a first logic circuit of the encoder determines if a fourth bit (d) of four bits (a, b, c, d) is a logic 0. If so, then a first selection circuit selects a wire to change states, the index of the selected wire determined by an additional two bits (a, b, in the form of a+2b), and the value of the new state of the selected wire is determined according to table T using the prior state of the selected wire and the data values of the remaining received data bit (c). However, if the fourth bit (d) is a logic 1, then a second logic circuit of the encoder determines if a second pair of two bits (b, c) are both 1, and if not, then two wires are selected for state transitions according to the indices determined by a combination of input bits such as a combination of bits a, c (ac+2ac), and the combination of a, b, c, (bc|c+2a c) as set forth above. But if both b and c are also logic 1 (and hence, b=c=d=1), then a third logic circuit also determines whether input bit a is a logic 0, and if so, causes the states of the first second and third wires to be updated according to their prior states and table T2. In the event that all bits are 1, then no wires change state. One of skill in the art will recognize that Boolean operations may be performed on the above relationships to yield equivalent expressions.
Decoding for TL4. The task of the decoder is to infer from a previous state p=(p[0], p[1], p[2], p[3]) and a successor state s=(s[0], s[1], s[2], s[3]) the bits a, b, c, d.
           Algorithm 4 Decoding for TL4               Input: Prior state p=(p[0], p[1],p[2],p[3]) and successor state s = (s[0],   s[1], s[2], s[3]) on the four wires, where p[i], s[i] ε {0, 1, 2}   Output: Bits a, b, c, d    1: a ← 1, b ← 1, c ← 1, d ← a    2: Calculate w = (s − p) mod 3    3: Determine weight of w, and call it m    4: Determine position a0 + 2b0 such that w[a0 + 2b0] /=    0, t ← w[a0 + 2b0]    5: If m > 1, determine position a1 + 2b1 such that w[a1+ 2b1] /= 0    6: a ← 1, b ← 1, c ← 1, d ← 1         Idle state    7: if m = 1 then    8:  a ← a0, b ← b0, c ← t − 1, d ← 0    9: end if   10:  if m = 2 then   11:  d ← 1, c ← 1 ⊕ b0  ⊕ b1         ⊕=XOR   12:  b ← (b0  ⊕ b1 )(a0 b0 ⊕ a1 b1 ), a ← a0 b1 /a1 b0    13:  end if   14:  if m = 3 then   15:  a ← 0, b ← 1, c ← 1, d ← 1   16:  end if               
The P2P SSO-Reducing Code

In accordance with at least one embodiment of the invention, a P2P code is described, which is a ternary codes on 2 wires. The code has 4 codewords that are each 2-dimensional. They are given below:
  (1/2, 0), (0, 1/2), (1/2, 1), (1,−1/2)

Power Consumption and SSO
 
Of the 16 possible transitions from one state to another, 8 consume a power of 0, 4 consume a power of 1/2, and 4 consume a power of 1. This gives an average power consumption of 3/8 on 2 wires, or 3/16≈0.1875 per wire. This is 75% of the average power consumption of single-ended signaling. The worst case SSO caused by this code is 1 on 2 wires, which is a factor of 2 better than the worst case SSO caused by single ended signaling. From the results above, the worst-case power consumption on an interface with 128 wires is 64 units, the average power consumption is 24 units, and the standard deviation from the average (assuming uniformly random input) is 3.32.
P2P Encoding and Decoding
The task of the encoder is to calculate a codeword upon receiving 4 bits (a,b,c,d).
For decoding, we assume that the (possibly equalized) values on the wires are x, y.
Two decoding variations are described. In the first, we collect the results of the following comparisons:
    Compare x against y and denote the corresponding bit by e. Compare (x+y)/2 against 0, and denote the corresponding bit by f.   
 FIG. 3 is a block diagram of an optimized receiver for the P2P code using this variation, in accordance with at least one embodiment of the invention.
In the second variation, two stacked CMOS single-ended receivers as shown in FIG. 2B are used to produce x_high, x_low, y_high, and y_low.
For either variation, a combinatorial digital logic circuit is used to recover the two original bits from these comparison results.
P4P SSO-Reducing Code
In accordance with at least one embodiment of the invention, the P4P code described, which is a variant of P4 code in which resistance to common mode is sacrificed in order to get an additional bit. The code has 16 codewords that are each 4-dimensional. They are given below:
  ±(1/2,1/6,1/6,−1/6), ±(1/2,1/6,−1/6,1/6), ±(1/6,−1/6,1/2,1/6), ±(1/6,−1/6,1/6,1/2) ±(1/6,1/2,1/6,−1/6), ±(1/6,1/2,−1/6,1/6), ±(−1/6,1/6,1/2,1/6), ±(−1/6,1/6,1/6,1/2)

Power consumption and SSO
 
Of the 256 transitions from one state to another, 64 consume 0 power, 48 consume power 1/3, 80 consume power 2/3, 48 consume power 4/3, and 16 consume power 5/3. This gives an average power consumption of 5/8 across 4 wires, and hence an average power consumption of 5/32 per wire, which is equal to 0.15625. This is 62.5% of the average power used by un-terminated single-ended signaling.
The SSO caused by the transitions is equal to 0 for half of the transitions, and equal to 4/3 for the other half. The worst case SSO is therefore 4/3, which is a factor of 3 better than the SSO caused by single-ended signaling. The average SSO is 2/3, which is also a factor of 3 better than the average SSO of single-ended signaling. From the results above, the worst case power consumption on an interface with 128 wires is 160/3≈53.33 units, the average power consumption is 20 units, and the standard deviation from the average (assuming uniformly random input) is 16.81.
P4P Encoding
The task of the encoder is to calculate a codeword upon receiving 4 bits (a,b,c,d). There are essentially two different ways to accomplish this. One is using a purely digital encoder with the following pseudo-code:



 
 
 
 
 
 
 
 
 
If d == 0 then
 
 
 
 Put a 1/2 on wire at position a+2*b
 
 
 
 Put a 1/6 on wires at positions (   a) + 2*b and (   c) + 
 
 
 
 2*(   b) /*    x is the NOT of x*/
 
 
 
 Put a −1/6 on wire at position c + 2*(   b)
 
 
 
Else
 
 
 
 Put a −1/2 on wire at position a+2*b
 
 
 
 Put a −1/6 on wires at positions (   a) + 2*b and (   c) + 
 
 
 
 2*(   b) /*    x is the NOT of x*/
 
 
 
 Put a 1/6 on wire at position c + 2*(   b)
 
 
 
 







For example, if the input bits are (a,b,c,d)=(1,1,1,0), then we will be in the first case since d=0. We put a 1/2 on wire at position 1+2*1=3, a 1/6 on wire at position 1+2*1=2 and on wire at position 1+2*(1)=0, and a−1/6 on wire at position 1+2*(1)=1. The codeword is therefore (1/6,−1/6,1/6,1/2).
    The second encoder uses a matrix representation of the code, and computes the following values in analog: given (a,b,c,d), represented in this case as +1 and −1 rather than 0/1, we do the following:
    Calculate (a+b+d)/6 and put the value on wire 1 Calculate (a−b+d)/6 and put the value on wire 2 Calculate (a+c−d)/6 and put the value on wire 3 Calculate (a−c−d)/6 and put the value on wire 4

P4P Decoding
   
The task of the decoder is to receive (possibly equalized) values x, y, z, u on the wires and to produce the bits a, b, c, d that have given rise to these values. The following description assumes the received bits are recovered as +1 and −1 rather than as 0 and 1. To achieve this task, the decoder will use four comparators. One of them compares a linear combination of the values x, y, z, u against a fixed reference 0, and the other three comparators compare linear combinations of some of the values against linear combinations of others.
    Compare (x+y+z+u)/4 against 0. This gives the bit a. Compare x against y. This gives the bit b. Compare z against u. This gives the bit c. Compare (x+y)/2 against (z+u)/2. This gives the bit d.   
 FIG. 4 is a block diagram of an optimized receiver for the P4P code, in accordance with at least one embodiment of the invention.
SNR of Decoder with Respect to Thermal Noise
We assume that the values on the wires are perturbed by independent additive white Gaussian noise terms with mean 0 and variance σ2. We will compute the probability of error for each of the comparators above.
    The first comparator compares (x+y+z+u)/4 against 0. The average value of this term is 1/6 for half of the codewords and −1/6 for the other half. The value (x+y+z+u)/4 is therefore ±1/6+m, where m is a Gaussian random variable with mean 0 and standard deviation σ/2. The probability that this term is less than 0 in case the average is 1/6 is 0.5erfc(1/3σ√{square root over (2)}). If the average of −1/6 the same probability is obtained. The second comparator compares x against y, or equivalently, x-y against 0. The average value of this random variable is 1/3 or −1/3, and hence the value of the random variable is ±1/3+m, where m is a Gaussian random variable of mean 0 and standard deviation σ√{square root over (2)}. The error probability of this comparator is 0.5erfc(1/6σ). The third comparator has very similar properties as the second one, and its error probability is 0.5erfc(1/6σ). The fourth comparator compares (x+y)/2 against (z+u)/2, or equivalently (x+y)/2−(z+u)/2 against 0. The average value of this random variable is +1/3, so this random variable is +1/3+m, where m is a Gaussian random variable of mean 0 and standard deviation σ. The probability that this term is less than 0 in case the average is 1/3 is 0.5erfc(1/3σ√{square root over (2)}). If the average of −1/3 the same probability is obtained.   
Altogether, the error probability that at least one of the comparators makes an error is at most

erfc(1/3σ√{square root over (2)})+erfc(1/6σ)≈erfc(1/6σ).  [Eqn. 2]

A numerical approximation reveals that to achieve a block error rate of 1e-15 we need an SNR=30.6 dB. The SNR is hence 6.5 dB worse than that of single-ended signaling.
H4P SSO-Reducing Code
In accordance with at least one embodiment of the invention, the H4P code is described, which is a variant of Kandou's H4-code in which resistance to common mode is sacrificed in order to get an additional bit. The code has 16 codewords that are each 4-dimensional. They are given below:
  ±(1/2,0,0,0), ±(0,1/2,0,0), ±(0,0,1/2,0), ±(0,0,0,1/2) ±(1/4,1/4,1/4,−1/4), ±(1/4,1/4,−1/4,1/4), ±(1/4,−1/4,1/4,1/4), ±(−1/4,1/4,1/4,1/4)

Power Consumption and SSO
 
Of the 256 transitions from one state to another, 52 consume 0 power, 24 consume a power of 1/4, 100 consume a power of 1/2, 16 consume a power of 3/4, 36 consume a power of 1, 24 consume a power of 5/4, and 4 consume a power of 3/2. The average power consumption of the 4-wire interface is therefore 13/32, and the average per-wire power consumption is 13/128 which is 0.10156. This is about 40% of the average power consumption of single-ended signaling (which is 0.25), and the worst-case power consumption per wire is 3/8, which is 37.5% of the worst-case power consumption of single-ended signaling. The SSO caused by the transitions is equal to 0 for half of the transitions, and equal to 1 for the other half. The worst case SSO is therefore 1, which is a factor of 4 better than the SSO caused by single-ended signaling on this 4-wire interface. The average SSO is 1/2, which is also a factor of 4 better than the average SSO of single-ended signaling. From the results above, the worst case power consumption on an interface with 128 wires is 48 units, the average power consumption is 17.5 units, and the standard deviation from the average (assuming uniformly random input) is 12.87.
H4P Encoding
The task of the encoder is to calculate a codeword upon receiving 4 bits (a,b,c,d). There are essentially two different ways to accomplish this. One is by using a purely digital encoder with the following pseudo-code:



 
 
 
 
 
 
 
 
 
If ( d == 0 ) then
 
 
 
 If ( c == 0 ) then
 
 
 
  Put 1/2 at position a+2b, and 0's elsewhere
 
 
 
 Else
 
 
 
  Put −1/2 at position a+2b, and 0's elsewhere
 
 
 
Else
 
 
 
 If ( c == 0 ) then
 
 
 
  Put 1/4 at position a+2b and −1/4's elsewhere
 
 
 
 Else
 
 
 
  Put −1/4 at position a+2b and 1/4's elsewhere
 
 
 
 







The second encoder uses a matrix representation of the code, and computes the following values in analog: given (a,b,c,d), this time as +1 and −1 (not 0/1), we do the following:
    Calculate (a+b+c+d)/8 and put the value on wire 1 Calculate (a+c)/8−(b+d)/8 and put the value on wire 2 Calculate (a+b)/8−(c+d)/8 and put the value on wire 3 Calculate (a+d)/8−(b+c)/8 and put the value on wire 4

H4P Decoding
   
The task of the decoder is to receive (possibly equalized) values x, y, z, u on the wires and to produce the bits a, b, c, d that have given rise to these values. We assume that these bits are recovered as +1 and −1 rather than as 0 and 1. To achieve this task, the decoder will use four comparators. One of them compares a linear combination of the values x, y, z, u against a fixed reference 0, and the other three comparators compare linear combinations of some of the values against linear combinations of others.
    Compare (x+y+z+u)/4 against 0. This gives the bit a. Compare (x+z)/2 against (y+u)/2. This gives the bit b. Compare (x+y)/2 against (z+u)/2. This gives the bit c. Compare (x+u)/2 against (y+z)/2. This gives the bit d.   
 FIG. 4 is a block diagram of an optimized receiver for the H4P code, in accordance with at least one embodiment of the invention.
SNR with Respect to Thermal Noise
We assume that the values on the wires are perturbed by independent additive white Gaussian noise terms with mean 0 and variance σ2. We will compute the probability of error for each of the comparators above.
    The first comparator compares (x+y+z+u)/4 against 0. The average value of this term is 1/8 for half of the codewords and −1/8 for the other half. The value (x+y+z+u)/4 is therefore ±1/8+m, where m is a Gaussian random variable with mean 0 and standard deviation σ/2. The probability that this term is less than 0 in case the average is 1/8 is 0.5erfc(1/4σ√{square root over (2)}). If the average of −1/8 the same probability is obtained. All the other comparators have the same error probability. For example, the third comparator compares (x+y)/2 against (z+u)/2, or equivalently (x+y)/2−(z+u)/2 against 0. The average value of this random variable is +1/4, so this random variable is +1/4+m, where m is a Gaussian random variable of mean 0 and standard deviation σ. The probability that this term is less than 0 in case the average is 1/4 is 0.5erfc(1/4σ√{square root over (2)}). If the average of −1/4 the same probability is obtained.   
Altogether, the error probability that at least one of the comparators makes an error is at most

2erfc(1/4σ√{square root over (2)}).  [Eqn. 3]

A numerical approximation reveals that to achieve a block error rate of 1e-15 we need at least SNR=30.2 dB. The SNR is hence 6.1 dB worse than that of single-ended signaling.
4b4wT SSO-Eliminating Code
In accordance with at least one embodiment of the invention, the 4b4w code described, which is a union of two Kandou's codes. The code provides complete resistance to SSO noise. The code has 16 codewords that are each 4-dimensional. They are given below:
  ±(1/2,−1/2,0,0), ±(1/2,0,−1/2,0), ±(1/2,0,0,−1/2), ±(0,1/2,−1/2,0), ±(0,1/2,0,−1/2), ±(0,0,1/2,−1/2), ±(1/2,−1/2,1/2,−1/2), ±(1/2,−1/2,−1/2,1/2)

Power Consumption and SSO
 
Of the 256 possible transitions from one state to another, 28 consume a power of 0, 84 consume a power of 1/2, and 144 consume a power of 1. This gives an average power consumption of 186/256=93/128 on 4 wires, or 93/512=0.181640625 per wire. This is about 73% of the average power consumption of single-ended signaling. The SSO caused by this code is 0. From the results above, the worst case power consumption on an interface with 128 wires is 32 units, the average power consumption is 23.25 units, and the standard deviation from the average (assuming uniformly random input) is 10.93.
4b4wT Encoding
The task of the encoder is to calculate a codeword upon receiving 4 bits (a,b,c,d). Here is a pseudo-code:



 
 
 
 
 
 
If (c & d) == 0 /* “&” is the logical AND */
 
 
 Put a 1 on wire at position a+2*b
 
 
 Put a −1 on wire at position (a⊕   c) + 2*(b⊕   d) /* “⊕”
 
 
  denotes XOR , and    c is the
 
 
NOT of c*/
 
 
 Put a 0 on the other two wires
 
 
Else
 
 
 Put a 1 on wires at positions a and b+2
 
 
 Put a −1 on wires at positions    a and (   b)+2
 
 
 







For example, if the input bits are (a,b,c,d)=(1,0,1,0), then we will be in the first case since the logical AND of 1 and 0 is 0. We put a 1 on wire at position 1+0*2=1, a−1 on wire at position (1⊕0)+2*(0⊕1)=3, and zeros on the other wires. The resulting codeword is thus (0,1,0,−1).
4b4wT Decoding: First Version
Decoding is done via several multi-input comparators. This can be done in several ways. One of these ways is described below.
We assume that the (possibly equalized) values on the wires are x, y, z, u. In a first step, we collect the results of the following 5 comparisons:
    Compare (x+2z)/3 against u and denote the corresponding bit by e. Compare (x+2b)/3 against u and denote the corresponding bit by f Compare (2x+u)/3 against y and denote the corresponding bit by g. Compare (2x+y)/3 against z and denote the corresponding bit by h. Compare (2u+z)/3 against x and denote the corresponding bit by i.   
A combinatorial digital logic circuit is used to recover the four original bits from these 5 bits.
 FIG. 5A is a block diagram of this receiver, in accordance with at least one embodiment of the invention.
4b4wT Decoding: Second Version
Again, we assume that the (possibly equalized) values on the wires are x, y, z, u. In a first step, we collect the results of the following 8 comparisons:
    Compare (x+5u)/6 against (y+z)/2 and denote the corresponding bit by e. Compare (x+y)/2 against (5z+u)/6 and denote the corresponding bit by f Compare (x+u)/2 against (5z+y)/6 and denote the corresponding bit by g. Compare (x+z)/2 against (5u+y)/6 and denote the corresponding bit by h. Compare (x+u)/2 against (5y+z)/6 and denote the corresponding bit by i. Compare (x+z)/2 against (5y+u)/6 and denote the corresponding bit by j. Compare (x+y)/2 against (5u+z)/6 and denote the corresponding bit by k. Compare (z+u)/2 against (5y+x)/6 and denote the corresponding bit by l.   
A combinatorial digital logic circuit is used to recover the four original bits from these 8 bits. FIG. 5B is a block diagram of this receiver, in accordance with at least one embodiment of the invention.
SNR with Respect to Thermal Noise
We follow the same analysis as the one for the previous cases. For the first version of the decoder, the smallest average values (in absolute value) that the comparators can have are ±1/6. Therefore, the actual values are equal to ±1/6+m, where m is a Gaussian random variable of mean 0 and standard deviation σ√{square root over (14)}/3. Therefore, the probability that any of the comparators calculates the wrong value is 0.5erfc(1/σ√{square root over (28)}), and the probability that at least one of the comparisons produces the wrong value is at most 2.5erfc(1/σ√{square root over (28)}). A numerical calculation shows that the SNR in this case is SNR=29.7 dB. The SNR is therefore 5.7 dB worse than that of single-ended signaling.
For the second version of the decoder the smallest average values (in absolute value) that the comparators can have are ±1/3. Therefore, the actual values are equal to ±1/3+m, where m is a Gaussian random variable of mean 0 and standard deviation σ√{square root over (11)}/3. Therefore, the probability that any of the comparators calculates the wrong value is 0.5erfc(1/σ√{square root over (22)}), and the probability that at least one of the comparators calculates the wrong value is at most 2.5erfc(1/σ√{square root over (22)}). A numerical calculation shows that the SNR in this case is SNR=28.6 dB.
The SNR is therefore 4.6 dB worse than that of single-ended signaling.
4b4wQ SSO-Eliminating Code
In accordance with at least one embodiment of the invention, the 4b4w code is described, which is one of Kandou's quaternary codes. The code provides complete resistance to SSO noise. The code has 16 codewords that are each 4-dimensional. They are given below:
  (−1/2, −1/6, 1/6, 1/2), (−1/6, −1/2, 1/6, 1/2), (−1/2, −1/6, 1/2, 1/6), (−1/6, −1/2, 1/2, 1/6) (1/6, −1/6, −1/2, 1/2), (1/6, −1/2, −1/6, 1/2), (1/2, −1/6, −1/2, 1/6), (1/2, −1/2, −1/6, 1/6) (−1/2, 1/2, 1/6, −1/6), (−1/6, 1/2, 1/6, −1/2), (−1/2, 1/6, 1/2, −1/6), (−1/6, 1/6, 1/2, −1/2) (1/6, 1/2, −1/2, −1/6), (1/6, 1/2, −1/6, −1/2), (1/2, 1/6, −1/2, −1/6), (1/2, 1/6, −1/6, −1/2)

Power Consumption and SSO
 
Of the 256 possible transitions from one state to another 16 consume a power of 0, 40 consume a power of 1/3, 64 consume a power of 2/3, 72 consume a power of 1, and 64 consume a power of 4/3. This gives an average power consumption of 5/6 on 4 wires, or 5/24 0.20833 per wire. This is about 83.33% of the average power consumption of single-ended signaling. The SSO caused by this code is 0. From the results above, the worst-case power consumption on an interface with 128 wires is 128/3≈42.67 units, the average power consumption is 20 units, and the standard deviation from the average (assuming uniformly random input) is 12.79.
4b4wQ Encoding
The task of the encoder is to calculate a codeword upon receiving 4 bits (a,b,c,d). Here is a pseudo-code:
               Put −1/2 on wire at position a + 2( (   a & c) |      (d & a) ) //   x is the NOT of x     Put −1/6 on wire at position    a + 2( (c & a) |      (d &    a) ) // “&” is the logical AND     Put 1/6 on wire at position b + 2( (   c &    b) |      (b &    d) ) // “|” is the logical OR     Put 1/2 on wire at position    b + 2( (   c & b) | (   b & d) )             
4b4wQ Decoding

We assume that the (possibly equalized) values on the wires are x, y, z, u. In a first step, we collect the results of the following 6 comparisons:
    Compare x against y and denote the corresponding bit by e. Compare x against z and denote the corresponding bit by f Compare x against u and denote the corresponding bit by g. Compare y against z and denote the corresponding bit by h. Compare y against u and denote the corresponding bit by i. Compare z against u and denote the corresponding bit by j.   
A combinatorial digital logic circuit is used to recover the four original bits from these 6 bits. FIG. 6 is a block diagram of an optimized receiver for the 4b4wQ code, in accordance with at least one embodiment of the invention.
SNR with Respect to Thermal Noise
In this case the SNR is exactly that of a reference-less PAM-4 receiver, which means that the required SNR to achieve 1e-15 error probability is about 30.5 dB.
2b2wT SSO-Reducing Code
In accordance with at least one embodiment of the invention, a 2b2wT code is described, which is one of Kandou's ternary codes on 2 wires. The code has 4 codewords that are each 2-dimensional. They are given below:
  (1/2,0), (−1/2,0), (0,1/2), (0,−12)

Power Consumption and SSO
 
Of the 16 possible transitions from one state to another, 8 consume a power of 0, 4 consume a power of 1/2, and 4 consume a power of 1. This gives an average power consumption of 3/8 on 2 wires, or 3/16≈0.1875 per wire. This is 75% of the average power consumption of single-ended signaling. The worst case SSO caused by this code is 1 on 2 wires, which is a factor of 2 better than the worst case SSO caused by single ended signaling. From the results above, the worst-case power consumption on an interface with 128 wires is 64 units, the average power consumption is 24 units, and the standard deviation from the average (assuming uniformly random input) is 3.32.
2b2wT Encoding
The task of the encoder is to calculate a codeword upon receiving 4 bits (a,b,c,d). Here is a pseudo-code:
               Put −1/2 on wire at position a + 2( (   a & c) |      (d & a) ) //   x is the NOT of x     Put −1/6 on wire at position    a + 2( (c & a) | (d &    a) ) //      “&” is the logical AND     Put 1/6 on wire at position b + 2( (   c &    b) |      (b &    d) ) // “|” is the logical OR     Put 1/2 on wire at position    b + 2( (   c & b) | (   b & d) )             
2b2wT Decoding

We assume that the (possibly equalized) values on the wires are x, y, z, u. In a first step, we collect the results of the following 6 comparisons:
    Compare x against y and denote the corresponding bit by e. Compare x against z and denote the corresponding bit by f. Compare x against u and denote the corresponding bit by g. Compare y against z and denote the corresponding bit by h. Compare y against u and denote the corresponding bit by i. Compare z against u and denote the corresponding bit by j.   
A combinatorial digital logic circuit is used to recover the four original bits from these 6 bits. FIG. 7 is a block diagram of an optimized receiver for the 2b2wT code, in accordance with at least one embodiment of the invention.
SNR with Respect to Thermal Noise
In this case the SNR is exactly that of a reference-less PAM-4 receiver, which means that the required SNR to achieve 1e-15 error probability is about 30.5 dB.
Summary and Comparison of Codes
 FIGS. 8A and 8B are charts summarizing and comparing the vector signaling code embodiments described herein in accordance with the invention.
The examples presented herein illustrate the use of vector signaling codes for point-to-point or bussed chip-to-chip interconnection. However, this should not been seen in any way as limiting the scope of the described invention. The methods disclosed in this application are equally applicable to other interconnection topologies and other communication media including optical, capacitive, inductive, and wireless communications. Thus, descriptive terms such as “voltage” or “signal level” should be considered to include equivalents in other measurement systems, such as “optical intensity”, “RF modulation”, etc. As used herein, the term “physical signal” includes any suitable behavior and/or attribute of a physical phenomenon capable of conveying information. Physical signals may be tangible and non-transitory.

We claim:
 
1. An apparatus comprising:
an encoder configured to receive a set of n bits, wherein n is a predetermined integer greater than or equal to 3, and to encode the set of n bits to a vector signaling code word as transitions from a previously transmitted vector signaling code word having a plurality of elements of three or more levels in the transmission interface, wherein the encoder is configured to check less than n bits of set of n bits for a first logic condition that if satisfied, configures the encoder to transition a level of a single element of the previously transmitted vector signaling code word according to a first transition-limiting function operating on a prior state of the level of the single element, and if the first logic condition fails, the encoder is configured to check less than n bits of the set of n bits for a second logic condition that if satisfied, configures the encoder to transition levels of two elements of the previously transmitted vector signaling code word according to a second transition-limiting function operating on prior states of the levels of the two elements; and
an output driver circuit configured to provide the vector signaling codeword in one transmission interval on a multi-wire bus.


  
2. The apparatus of claim 1, wherein the multi-wire bus comprises n wires, and wherein the vector signaling code word comprises n elements.

  
3. The apparatus of claim 1, wherein the encoder is configured to implement the first and second transition-limiting functions using a lookup table.

  
4. The apparatus of claim 1, wherein the output driver circuit is a ternary driver circuit, the multi-wire bus comprises a first wire, a second wire, and a third wire, and wherein the encoder is configured to:
receive three input bits at an input and to obtain prior output states of the wires of the ternary driver circuit, the three input bits comprising a first bit, a second bit, and a third bit;
determine, for the first logic condition, that the second and the third bits of the three input bits are not both ones, and to responsively select an output wire based on the second and the third bits, and to determine a new output state of the selected wire according to the first transition-limiting function operating on the a prior state of the level of the selected wire and the first input bit; and
determine, for the second logic condition that the first bit is zero, and to responsively determine new output states of the first wire and the second wire according to the second transition-limiting function operating on prior states of levels of the first and second wires, respectively.


  
5. The apparatus of claim 4, wherein the encoder is configured to select the output wire based on the index of the wire as determined by a sum of the second bit and two times the third bit.

  
6. The apparatus of claim 5, wherein the encoder is configured to select the new output state based on a modulo-3 summation.

  
7. The apparatus of claim 1, wherein the output driver circuit is a quaternary driver circuit, the multi-wire bus comprises a first wire, a second wire, a third wire, and a fourth wire, and wherein the encoder is configured to:
receive four input bits at an input, the four input bits comprising a first bit, a second bit, a third bit, and a fourth bit and to obtain prior output states of the quaternary driver circuit;
determine, for the first logic condition, that the fourth bit is a zero;
select, for the first transition-limiting function, from the multi-wire bus, an output wire based on the first bit and the second bit, and to select a new output state of the selected wire based on a prior state of a level of the selected wire and the third bit;
determine, for the second logic condition, that the second and third bits are not both ones, and to responsively select a pair of wires, wherein a first wire of the pair is selected according to a corresponding index determined by a combination of the first and third bits, and wherein a second wire of the pair is selected according an index determined by the first, second, and third bits, the encoder configured to determine new output states for the pair of wires according to the second transition-limiting function operating on previous states of levels of the first and second wires of the selected pair of wires, respectively; and
in response to determining that the first and second logic conditions fail, the encoder is configured to determine, for a third logic condition, that the first bit is a zero, and to responsively determine new output states of the first wire, the second wire, and the third wire, wherein the new output states are determined according to the second transition-limiting function operating on prior states of levels of the first wire, the second wire, and the third wire, respectively.


  
8. The apparatus of claim 7, wherein the encoder is configured to select the output wire based on the index of the wire as determined by a sum of the first bit and two times the second bit.

  
9. The apparatus of claim 8, wherein the encoder is configured to determine the new output state of the selected wire based on a modulo-3 summation.

  
10. The apparatus of claim 1, further comprising a state memory circuit configured to provide the previously transmitted vector signaling code word to the encoder.

  
11. A method comprising:
receiving a set of n bits, wherein n is a predetermined integer greater than or equal to 3;
encoding the set of n bits into a vector signaling codeword as transitions from a previously transmitted vector signaling codeword comprising a plurality of elements of three or more values, wherein the encoding comprises checking one or more bits for a first logic condition that if satisfied, transitions a value of a single element of the previously transmitted vector signaling codeword according to a first transition-limiting function operating on a prior state of the value of the single element, and if the first logic condition fails, checking less than n bits for a second logic condition that if satisfied, transitions values of two elements of the previously transmitted vector signaling codeword according to a second transition-limiting function operating on prior states of the levels of the two elements; and
transmitting the vector signaling code word in one transmission interval on a set of wires.


  
12. The method of claim 11, wherein the set of wires comprises n wires, and wherein the vector signaling code word comprises n elements.

  
13. The method of claim 11, wherein the first and second transition-limiting functions are implemented using a lookup table.

  
14. The method of claim 11, wherein:
encoding comprises receiving three input bits comprising a first bit, a second bit, and a third bit, and obtaining prior output states of a ternary driver circuit configured to drive the set of wires comprising a first wire, a second wire, and a third wire;
the first logic condition comprises determining that the second bit and the third bit are not both ones;
the first transition-limiting function comprises selecting an output wire based on the second and the third bit, and determining a new output state of the selected wire according to the first transition-limiting function operating on a prior state of a value of the selected wire and the first input bit;
the second logic condition comprises determining that the first bit is a zero; and
the second transition-limiting function comprises determining new output states of the first wire and the second wire, wherein the new output states are determined according to the second transition-limiting function operating on prior states of values of the first and second wires, respectively.


  
15. The method of claim 14, wherein selecting the output wire is based on the index of the wire as determined by a sum of the second bit and two times the third bit.

  
16. The method of claim 15, wherein the new output state of the selected wire is based on a modulo-3 summation.

  
17. The method of claim 11, wherein:
the set of wires comprises a first wire, a second wire, a third wire, and a fourth wire
encoding comprises receiving (i) four input bits at an encoder, the four input bits comprising a first bit, a second bit, a third bit, and a fourth bit and (ii) obtaining prior output states of a quaternary driver circuit;
the first logic condition comprises determining that the fourth bit is a zero;
the first transition-limiting function comprises selecting, from the set of output wires, an output wire based on the first bit and the second bit, and selecting a new output state of the selected wire based on the first transition-limiting function operating on a prior state of a value of the selected wire and the third bit;
the second logic condition comprises determining that the second and the third bit are not both ones, and responsively selecting a pair of wires, wherein a first wire of the pair is selected according to a corresponding index determined by a combination of the first and third bits, and wherein a second wire of the pair is selected according an index determined by the first, second, and third bits, and wherein new output states for the pair of wires are determined according to the second transition-limiting function operating on previous states of values of the first and second wires of the selected pair of wires, respectively; and
responsive to determining that the first and second logic conditions fail, determining for a third logic condition, that the first bit is a zero, and responsively determining new output states of the first wire, the second wire, and the third wire, wherein the new output states are determined according to the second transition-limiting function operating on prior states of values of the first wire, the second wire, and the third wire, respectively.


  
18. The method of claim 17, wherein selecting the output wire is based on the index of the wire as determined by a sum of the first bit and two times the second bit.

  
19. The method of claim 18, wherein the new output state of the selected wire is based on a modulo-3 summation.

  
20. The method of claim 11, wherein the previously transmitted vector signaling code word is obtained from a state memory circuit.
# US9424908B2 - US9424908B2 - Differential vector storage for dynamic random access memory 
        - Google Patents

## Details

* Date: 2010-12-30
* Inventor: Kandou Labs SA
* Beneficiary: Harm Cronie, Amin Shokrollahi
## Other patents

### Backwards
 * US3196351A
 *US3636463A
 *US3939468A
 *US4163258A
 *US4181967A
 *US4206316A
 *US4276543A
 *US4486739A
 *US4499550A
 *US4774498A
 *US4864303A
 *US4897657A
 *US4974211A
 *US5053974A
 *US5166956A
 *US5168509A
 *US5283761A
 *US5287305A
 *US5412689A
 *US5449895A
 *US5459465A
 *US5511119A
 *US5553097A
 *US5599550A
 *US5659353A
 *US5802356A
 *US5825808A
 *US5875202A
 *US5945935A
 *US5995016A
 *US5999016A
 *US6005895A
 *US6084883A
 *US6119263A
 *US6172634B1
 *US6175230B1
 *US6232908B1
 *US6278740B1
 *US6346907B1
 *US20020044316A1
 *US20020057592A1
 *US6404820B1
 *US6417737B1
 *US6452420B1
 *US20020154633A1
 *US6483828B1
 *US6509773B2
 *US6556628B1
 *US6563382B1
 *JP2003163612A
 *US20030146783A1
 *US6621427B2
 *US6624699B2
 *US6650638B1
 *US6661355B2
 *US6686879B2
 *US6766342B2
 *US6839429B1
 *US6839587B2
 *US6854030B2
 *US6865236B1
 *US6865234B1
 *US20050057379A1
 *US6898724B2
 *US6927709B2
 *US20050174841A1
 *US20050213686A1
 *US6954492B1
 *US6963622B2
 *US6973613B2
 *US6976194B2
 *US6982954B2
 *US6990138B2
 *US6999516B1
 *US7023817B2
 *US7053802B2
 *US7075996B2
 *US7085153B2
 *US7085336B2
 *US7142612B2
 *US7142865B2
 *US7164631B2
 *US7167019B2
 *US7180949B2
 *US20070188367A1
 *US7269212B1
 *US20070263711A1
 *US7335976B2
 *US7339990B2
 *US7348989B2
 *US7349484B2
 *US7356213B1
 *US7358869B1
 *US20080104374A1
 *US7370264B2
 *US7389333B2
 *US7428273B2
 *US7456778B2
 *US7462956B2
 *US7496162B2
 *US20090059782A1
 *US7535957B2
 *CN101478286A
 *WO2009084121A1
 *US7570704B2
 *US7599390B2
 *US7616075B2
 *US7633850B2
 *US7639596B2
 *US7643588B2
 *US7656321B2
 *US20100046644A1
 *WO2010031824A1
 *US7694204B2
 *US7697915B2
 *US7706524B2
 *US7706456B2
 *US7746764B2
 *US20100180143A1
 *US7787572B2
 *US7804361B2
 *US7808883B2
 *US20100296556A1
 *US7841909B2
 *US7869497B2
 *US7882413B2
 *US7899653B2
 *US7933770B2
 *WO2011119359A2
 *US8036300B2
 *US8050332B2
 *US8055095B2
 *US8064535B2
 *US20110299555A1
 *US8085172B2
 *US8091006B2
 *US8106806B2
 *US8159375B2
 *US8159376B2
 *US8180931B2
 *US8185807B2
 *US8199863B2
 *US8199849B2
 *US20120152901A1
 *US20120161945A1
 *US8218670B2
 *US8245094B2
 *US8253454B2
 *US8279094B2
 *US8295250B2
 *US8310389B1
 *US20130010892A1
 *US8365035B2
 *EP2039221B1
 *US8406315B2
 *US8429495B2
 *US8443223B2
 *US8442099B1
 *US8451913B2
 *US8462891B2
 *US8472513B2
 *US8498368B1
 *US8520348B2
 *US8539318B2
 *US8547272B2
 *US8578246B2
 *US8577284B2
 *US8588254B2
 *US8588280B2
 *US8593305B1
 *US8638241B2
 *US8649840B2
 *US8649445B2
 *US8649556B2
 *US8711919B2
 *US8718184B1
 *US8773964B2
 *US8780687B2
 *US8782578B2
 *US20140226455A1
 *US8879660B1
 *US8897134B2
 *US20150010044A1
 *US8949693B2
 *US8951072B2
 *US8975948B2
 *US20150078479A1
 *US8989317B1
 *US9020049B2
 *US9036764B1
 *US9069995B1
 *US9077386B1
 *US20150199543A1
 *US9093791B2
 *US9100232B1
 *US9106465B2
 *US9124557B2
 *US9172412B2
 *US20150333940A1
 *US9197470B2
 *US20150381232A1
 *US20160020796A1
 *US20160020824A1
 *US20160036616A1
 *US9281785B2
 *US9331962B2
 *US9362974B2
### Forward
 * 
## Abstract

Abstract

A storage device stores data in groups of memory cells using vectors corresponding to voltage code codewords, each codeword having k entries. Entries have values selected from a set of at least three entry values and 2n distinct inputs can be encoded into k-entry codewords for some n>k. A vector storage element comprising k cells can store an k electrical quantities (voltage, current, etc.) corresponding to a codeword. The voltage code is such that, for at least one position of a vector, there are at least three vectors having distinct entry values at that position and, for at least a subset of the possible codewords, the sum of the entry values over the positions of each vector is constant from vector to vector in that subset. The storage device might be an integrated circuit device, a discrete memory device, or a device having embedded memory.



A storage device stores data in groups of memory cells using vectors corresponding to voltage code codewords, each codeword having k entries. Entries have values selected from a set of at least three entry values and 2n distinct inputs can be encoded into k-entry codewords for some n>k. A vector storage element comprising k cells can store an k electrical quantities (voltage, current, etc.) corresponding to a codeword. The voltage code is such that, for at least one position of a vector, there are at least three vectors having distinct entry values at that position and, for at least a subset of the possible codewords, the sum of the entry values over the positions of each vector is constant from vector to vector in that subset. The storage device might be an integrated circuit device, a discrete memory device, or a device having embedded memory.

CROSS-REFERENCES TO RELATED APPLICATIONS
This application is a continuation of U.S. application Ser. No. 13/843,785, filed Mar. 15, 2013, entitled “Differential Vector Storage for Dynamic Random Access Memory”, which claims priority from the U.S. Provisional Patent Application No. 61/697,515, filed Sep. 6, 2012, entitled “Differential Vector Storage for Dynamic Random Access Memory”, and are incorporated by reference herein in their entirety.
The following prior applications are herein incorporated by reference in their entirety for all purposes:
[Cronie-2] U.S. patent application Ser. No. 12/982,777, filed Dec. 30, 2010, naming Harm Cronie and Amin Shokrollahi, entitled “Power and Pin Efficient Chip-to-Chip Communications with Common-Mode Resilience and SSO Resilience.”
[Cronie-3] U.S. Provisional Patent Application 61/697,540, filed Sep. 6, 2012, naming Harm Cronie and Brian Holden, entitled “Sorting Decoder.”
FIELD OF THE INVENTION
The present inventions relate to, among other things, circuitry and techniques of dynamic random access memory and more particularly to methods and apparatus for generating, storing, reading, encoding, and decoding storage data.
BACKGROUND OF THE INVENTION
Random Access Memory (“RAM”) is a form of data storage that is used in modern computing devices and other electronic devices to store information. RAM can be embodied in a dedicated RAM chip that has as its only purpose the storage of information, or it can be part of a chip or circuit that has other functions, such as a system-on-a-chip that has RAM, a processor and other elements on a chip. While not intending any limitation to particular examples, RAM examples herein will assume that the RAM is present on a chip (or a plurality of chips) where the chip is made using semiconductor processing techniques or other techniques to all for information to be written to the RAM and later read back out of the RAM.
RAM is generally understood to be only capable of storing its contents while some power is applied to the RAM chip. “Storage” is a process that might encompass accepting data and address locations, writing that data to the specified address locations, maintaining some state of the RAM chip and/or the data, receiving read requests for data from address locations specified in the read requests and outputting that data. Preferably, unless there is a power interruption, the data read from a given address location of a RAM chip is the same as the data written to that address location with greater than some probability.
For a RAM to have storage capability, it has some structures that store data/stage. This can be through the use of electronic devices or elements, such as transistors, capacitors, and the like. Some RAM is referred to as Dynamic Random Access Memory (“DRAM”), in that the information is stored in devices or elements that need to be maintained or refreshed in order to hold onto the stored data. For example, in some modes of operation, a DRAM stores information as charge on a capacitor and the charge is maintained until power is removed or the charge is changed during a write operation. Information can be read and/or written using a transistor coupled with the capacitor.
In a known DRAM chip, there are a number of addressable data cells and each data cell comprises one transistor and one capacitor. This is often referred to as a 1-transistor-1-capacitor (1T1C) DRAM data cell. To store one bit of data into a 1T1C DRAM cell, the capacitor is charged to one of two signal levels, with the particular one of the two signal levels determined by the bit being written to the cell. Without loss of generality, when one bit is being referenced, the two possible values for the bit are referred to as “0” and “1”.
To read a value of the DRAM cell, the cell is connected to a bitline BL and to a word line WL. During sensing, the cell capacitance is connected to a much larger BL capacitance and the resulting attenuated cell signal on the BL is compared by a sensitive differential sense amplifier with a similarly attenuated reference voltage obtained, as an example, from a similar BL having no activated cells. The amplified cell signal can then be stored back into the cell. This operation is often called the “refresh” operation. Refresh operations are necessary in a DRAM since the capacitors used to store the information exhibit leakage and therefore need to be refreshed to guarantee the integrity of the data stored. In such a scheme, storing the data “0” can correspond to the voltage level Vss whereas storing the data “1” could correspond to the voltage level Vdd, with Vss typically being a higher voltage level relative to Vdd. Of course, this relationship is not required. The voltage levels might be referred to by values relative to a ground plane, or some other circuit or chip reference. In many examples herein, voltages are relative to Vss and for clarity, this is not specified each time. Thus, when voltages are referred to as numbers or quantities, it might be that Vss=0. Unless otherwise indicated, the units for such numbers or quantities are volts, but other scales might be used instead.
Two parameters of importance in the design of a DRAM are the “density” and the energy consumption. The density of a DRAM can be described by the number of bits that can be stored in a given unit of area. Generally, DRAMs of higher density are preferred over DRAMs of lower density because of the smaller packaging, and several other economic advantages. A large portion of the energy consumption of a DRAM is spent in the “refresh” operation whereby the information in each cell is read, amplified, and written back to the cell. This refresh operation is necessitated by the fact that the capacitors used to store information have small capacitance because of their physical size, and hence lose charge over time. Because of process variations of the electronic components used in a DRAM, the refresh interval, i.e., the amount of time passed between two successive refreshes of a cell, has to be short enough so that the worst cells still have not lost their information at the time of refresh. According to the standards set forth by the “Joint Electron Devices Engineering Council” (JEDEC), DRAM manufacturers need to make sure that the process variations which their devices are subject to are such that with the refresh interval of 64 ms (milliseconds), their devices do not lose data (with some level of certainty).
The response of the DRAM industry to the problem of storage density has been mostly confined to feature size reduction due to process technology improvements, reduction of the footprint of a storage cell, and sometimes other approaches such as 3D-stacking. Feature size and footprint reduction need to obey the rule that the cell size has to be F2 or larger, wherein F is the so-called minimum feature size and depends on the process technology used. A process technology of 32 nm, for example, has 32 nm as the value of F. DRAM units in use today have a cell size equal to 6*F2. Experimental designs have been reported that reduce this size even further, but reducing cell size is still a big challenge for the industry.
 FIG. 1 is an exemplary block diagram schematic of a DRAM device 100 that is a conventional DRAM storage device. DRAM device 100 comprises a column decoder 130, I/O buffers 120, sense amplifiers 145, row decoders 110, and a memory area 140. Memory area 150 contains a plurality of actual memory cells. The memory cells are connected, via bitlines 133, to sense amplifiers 145 and column decoder 130, and, via wordlines 150, to row decoders 110. One of the memory cells in memory area 140 is indicated as memory cell 135 in FIG. 1 shown by a circle at an intersection of one wordline and one bitline. Although not shown explicitly, there can be connections between I/O buffers 120 and other elements of DRAM device 100, and there can be inputs of DRAM device 100 that are for row decoders 110 and outputs of DRAM device 100 that are for column decoder 130.
In operation, to write to a memory cell in response to DRAM device 100 receiving an input comprising the value to be written and a memory location to be written to, DRAM device 100 conveys the memory location (or at least part of it) to row decoders 110, which then activates one of wordlines 150 and DRAM device 100 conveys part of the memory location to column decoder 130, which then activates one or more of bitlines 133. DRAM device 100 might store the data temporarily in I/O buffers 120 and then move the data into the selected memory cell(s) via sense amplifiers 145. DRAM device 100's on-board logic (not explicitly shown) can charge the cell capacitance or discharge it, using the bitlines and the wordlines, based on the data to be written.
 FIG. 2 provides an expanded view of memory cell 135, showing additional structure. Memory cell 135 is shown comprising a transistor 230 and a capacitor 250. Parts of a bitline 133(i) and a wordline 150(j) are shown and in this example, memory cell 135 is in row j and column i of memory area 140. Transistor 230 is shown coupled to bitline 133(i), wordline 150(j) (at the gate of transistor 230), and capacitor 250. The other side of capacitor 250 can be coupled to a ground, a reference, or elsewhere.
Capacitor 250 stores a charge that corresponds to the data state of the data stored in memory cell 135. During a write operation, when wordline 150(j) is activated (by row decoders 110; see FIG. 1), transistor 230 turns on and charge from bitline 133(i) transfers to capacitor 250. The charge stored in memory cell 135 is used to determine the “value” stored therein. Memory cell 135 can be read by activating wordline 150(j) and sensing the charge on capacitor 250 using bitline 133(i).
 FIG. 3 illustrates a memory circuit where pre-charging is used. FIG. 3 shows portions of two memory arrays, with a first memory array 300 coupled to wordlines 302(1)-(3) and bitlines 320(a)-(c), and a second memory array 301 coupled to wordlines 312(1)-(3) and bitlines 330(a)-(c). Bitlines 320(a)-(c) and bitlines 330(a)-(c) are coupled to corresponding sense amplifiers 350(a)-(c), i.e., bitline 320(a) and bitline 330(a) are inputs to sense amplifier 350(a) and so on.
With bitlines 320 pre-charged to Vdd/2, bitlines 330 will be read by opening wordlines 312 and the difference of the charge to the pre-charged values of bitlines 320 are measured by sense amplifiers 350. These readings are then forwarded to row decoders (not shown) for obtaining the bit values in each cell. Thus, in conventional DRAM, each memory cell stores a charge in its associated capacitor and outputs a charge from the associated capacitor that corresponds directly to the value of the data received by the DRAM's I/O buffers and output from the I/O buffers.
The measurements of the charges in each cell are done with respect to the fixed reference Vdd/2. This has some significant implications. One of the implications is that the charges in the cells cannot fall below Vdd/2 if appropriate data state is to be reliably and repeatedly determined, and a suitable threshold depends on the sensitivity of the sense amplifiers.
The voltage read, Vr, from the capacitor at time t in a typical model, can be expressed as in Equation 1, wherein V is the original voltage applied to the capacitor, t is the time passed since the original voltage was applied, a is a decay parameter, and i is a normal random variable modeling the process variation of the cells.







Vr
=

V
⁢

 

⁢

ⅇ

-


t
α

τ








(

Eqn
.

 

⁢
1

)







From Equation 1, it should be apparent that memory cells storing a greater charge in their capacitor decay faster than cells storing a smaller charge. To guarantee the integrity of the DRAM device, appropriate refresh intervals are therefore necessary.
This constraint is more significant for multilevel DRAMs, where information is stored as more than two charge levels. In multilevel DRAMs, the decay between some levels is faster than others and refreshing needs to take into account these variations. Note that, per Equation 1, the charge on the capacitor would go from Vdd to below Vdd/2, for example, in about the same time that it needs to drop, for example, from Vdd/2 to below Vdd/4.
REFERENCES

 
[Ferrant] U.S. Pat. No. 7,085,153 to Ferrant et al., entitled “Semiconductor Memory Cell, Array, Architecture and Device, and Method of Operating Same” issued Aug. 1, 2006.

BRIEF SUMMARY
In embodiments of storage devices, circuitry is provided for storing data using groups of memory cells, wherein each memory cell of a group is capable of storing charge at three or more specified levels. A group of memory cells forms a vector storage element capable of storing codewords of a voltage code, wherein the number of possible codewords is greater than or equal to 2n, thereby allowing distinct codewords to encode for each possible n-bit value. The vector storage element comprises k cells and the corresponding codewords comprise k entries, wherein a cell in an i-th position of the vector storage element can store an electrical quantity, such as a voltage, current, etc., corresponding to an i-th entry of the corresponding codeword. The set of possible entry values and stored electrical quantities is greater than two for at least some of the vectors and some of the vector's entries. In some embodiments, there are 2n k-entry codewords and n>k. A voltage code has a “code rate” of n/k that is determined by the number of distinct codewords and the number of cells needed to store codewords. The voltage code is such that, for at least one position of a vector, there are at least three vectors having distinct entry values at that position and, for at least a subset of the possible codewords, when the entry values are assigned numerical summable values, the sum of the entry values over the positions of the each vector is constant from vector to vector in that subset. The assigned numerical summable values might correspond to voltages relative to some reference or otherwise, such as a voltage stored as charge on a capacitor.
In specific embodiments, the storage device might be an integrated circuit device, a discrete memory device, or a device having embedded memory. The storage device might include row decoder circuitry and column decoder circuitry such that row and column signals input to the storage device access, indicate, designate, identify, and/or select a subset of the memory cells, such as one or more vector storage elements. The memory cells might form a memory area on the device, with the memory cells arranged in a matrix of rows and columns. The storage device also includes data inputs/outputs and data encoder/decoder circuitry to generate vectors from input data and determine output data from vectors read from a vector storage element.
In specific embodiments, the data encoder circuitry receives an input corresponding to n input bits and generates a voltage codeword comprising k values that sum to a constant and can vary among three or more values, with n<k, while the data decoder circuitry receives a voltage codeword comprising k values, determines intended values for the k values (which might be altered by physical processes between reading and writing) and generates an output corresponding to n output bits.
Other objects and/or advantages of the present invention will be apparent to one of ordinary skill in the art upon review of the Detailed Description and the included figures.

BRIEF DESCRIPTION OF THE DRAWINGS
Various embodiments in accordance with the present disclosure will be described with reference to the drawings in FIG. 1 through FIG. 21.
 FIG. 1 is a schematic diagram illustrating a conventional memory device.
 FIG. 2 is a schematic diagram illustrating a memory cell as might be present in the conventional memory device of FIG. 1.
 FIG. 3 is a schematic diagram illustrating a differential sense amplifier in a conventional memory device.
 FIGS. 4A and 4B provide block diagrams of a memory device which performs operations on groups of memory cells.
 FIG. 5 is a schematic diagram of one group of memory cells as in FIG. 4.
 FIG. 6 is a block diagram of an encoder for storing data in a group of memory cells.
 FIG. 7 is a block diagram of a decoder for reading data from a group of memory cells.
 FIG. 8 is a flow chart for a memory refresh operation.
 FIG. 9 is a flow chart for a rank encoder operation.
 FIG. 10 is a flow chart for a rank decoder operation.11 
 FIGS. 11A, 11B, and 11C illustrate the operation of particular SWAP circuits.
 FIG. 12 is a circuit diagram showing the operation of an unrolled version of the rank decoding procedure.
 FIG. 13 shows the operation of a conditional swap circuit.
 FIG. 14 shows a memory device incorporating a voltage code program circuit.
 FIGS. 15A and 15B illustrate the use of an outer ECC in encoding and decoding.
 FIGS. 16A and 16B show block diagrams for embedded and discrete memory devices.
 FIGS. 17A, 17B and 17C illustrate memory device integration into systems.
 FIG. 18 is pseudocode for a ranking encoder.
 FIG. 19 is pseudocode for a ranking decoder.
 FIG. 20 is a flow chart for the process of selecting suitable rate 4/3 vectors.
 FIG. 21 shows a table of values obtained by the process of FIG. 20.

DETAILED DESCRIPTION OF THE INVENTION
There are many inventions described and illustrated herein, as well as many aspects and embodiments of those inventions. In one aspect, the present inventions relate to, among other things, circuitry and techniques for use with dynamic random access memory (for example, a discrete type or embedded type configuration or architecture). In one aspect, the circuitry and techniques encode n bits of storage data to generate a codeword of length k bits based on a voltage code, where n is greater than k. In a storage device, circuitry is provided for storing data using groups of memory cells, wherein each memory cell of a group is capable of storing charge at three or more specified levels. A group of memory cells forms a vector storage element capable of storing codewords of a voltage code, wherein the number of possible codewords is greater than or equal to 2n, thereby allowing distinct codewords to encode for each possible n-bit value. The vector storage element comprises k cells and the corresponding codewords comprise k entries, wherein a cell in an i-th position of the vector storage element can store an electrical quantity, such as a voltage, current, etc., corresponding to an i-th entry of the corresponding codeword. The set of possible entry values and stored electrical quantities is greater than two for at least some of the vectors and some of the vector's entries. In some embodiments, there are 2n k-entry codewords and n>k. A voltage code has a “code rate” of n/k that is determined by the number of distinct codewords and the number of cells needed to store codewords. The voltage code is such that, for at least one position of a vector, there are at least three vectors having distinct entry values at that position and, for at least a subset of the possible codewords, when the entry values are assigned numerical summable values, the sum of the entry values over the positions of the each vector is constant from vector to vector in that subset. The assigned numerical summable values might correspond to voltages relative to some reference or otherwise, such as a voltage stored as charge on a capacitor.
The target voltages might be selected from a set of possible target voltages having a maximum value and a minimum value, relative to some reference. For example, the reference might be the ground plane (Vss) and the set of possible target voltages being somewhere between 0 volts and Vdd volts (a supply voltage). As but one example, the set of possible target voltages is {0.75*Vdd, 0.50*Vdd, 0.25*Vdd, 0} or as another example, {0.5*Vdd, 0.4*Vdd, 0.3*Vdd, 0}. The individual entries of the vector may be interpreted as voltages, which are written or injected into associated memory cells. After encoding the storage data, the codeword is stored in k associated memory cells. During a read operation, the data stored in the k associated memory cells are read and decoded to recover the n bits of original storage data. The memory cells may be dynamic random access memory (“DRAM”) cells.
Some advantages of some embodiments are that memory density is enhanced in that n data bits of storage data (after encoding) are stored in k associated memory cells as a codeword, where n>k, and/or that refresh considerations are relaxed, wherein refresh considerations are based, at least in part, on the relative charge retention characteristics of the memory cells storing the coded storage data of the codeword.
The circuitry and techniques described herein may provide a dynamic random access memory implementing read operations that require no reference signal (voltage or current) to read the data states stored in the memory cells and/or decode the encoded storage data to recover the original data. Here, in one embodiment, the read and decode circuitry may recover the original data based on, for example, the relative voltage levels stored in the k associated memory cells (which stored the codeword that is representative of the original storage data).
Notably, as intimated above, the dynamic random access memory described herein may be implemented in a discrete type configuration/architecture (for example, a stand-alone memory device) and/or embedded type configuration/architecture (for example, an integrated circuit device having logic circuitry and one or more dynamic random access memory cells and/or arrays incorporated therein or thereon). Moreover, one or more aspects of the circuitry and techniques described herein (for example, the encoding and/or decoding circuitry and techniques) may be implemented in circuitry which is located “off-chip” relative to the discrete type and/or embedded type configuration/architectures. Other physical configurations or architectures which implement the techniques described herein might be used.
 FIG. 4A illustrates an embodiment of an integrated circuit device (for example, a discrete memory device and/or device having embedded memory) according to aspects of the present invention. The device is shown including row and column decoder circuitry 402, storage data encoder circuitry 404, a memory area 440 comprising a plurality of memory cells (not shown), and storage data read/decoder circuitry 408. As shown, row and column decoder circuitry 402 receive row/column addresses as inputs and have outputs to memory area 440 to provide for selection of particular memory cells of memory area 440. Storage data encoder circuitry 404 is shown with input for storage data 401 a and output for conveying code data 406 a to memory area 440. Storage data read/decoder circuitry 408 is shown with input for reading code data 406 b from memory area 440 and output for conveying storage data 401 to an output. For a given set of rows and/or columns where code data is stored, it is desirable that code data 406 b be close enough to code data 406 a so that storage data 401 b is equal to 401 a with a sufficiently high probability (excepting, of course, when there is a power loss or other erasing event between the read and write). Some typical probabilities might be greater than 1−10^15 probability of correct reads.
In this example, storage data encoder circuitry 404 generates a codeword of length k bits using the n bits of storage data 401 a, where n is greater than k. Storage data encoder circuitry 404 generates the codeword based on a voltage code, such as the voltage codes described herein.
In one embodiment, storage data encoder circuitry 404 includes mixed signal circuitry to generate the voltage levels for the individual entries of code data 406 a. In addition, storage data encoder circuitry 404 may also include one or more state machines, processors (suitably programmed) and/or field programmable gate arrays (or combinations thereof); indeed, any circuitry (for example, discrete or integrated logic, state machine(s), processor(s) (suitably programmed) and/or field programmable gate array(s) (or combinations thereof)) now known or later developed may be employed to calculate, generate and/or determine the codeword using the storage data.
In operation, storage data encoder circuitry 404 may perform or execute one or more applications, routines, programs and/or data structures that implement particular methods, techniques, tasks or operations described and illustrated herein. The functionality of the applications, routines or programs may be combined or distributed among a plurality of circuits (which may be integrated with storage data encoder circuitry 404 or separate therefrom). Further, the applications, routines or programs may be implemented by storage data encoder circuitry 404 using any programming language whether now known or later developed, including, for example, assembly, FORTRAN, C, C++, and BASIC, whether compiled or uncompiled code.
In one embodiment, storage data encoder circuitry 404 encodes storage data 401 a to be stored in memory area 440 into groups of k values or memory cells 435. These values need not be binary, i.e., a memory cell might be charged to a target voltage where the target voltage is one of three or more possible target voltages. The row and column decoder circuitry indicates, identifies, and designates the address of the specific memory cells. The memory cells may be organized in groups of at least two cells and preferably in groups of k memory cells. In general, the vector of k values or memory cells obtained may belong to a voltage code. For purposes of this description, a voltage code of length k (which is stored in k memory cells) is a collection of vectors of length k such that, for at least one coordinate position 1, k, there are at least three vectors having distinct values for their entry at that coordinate position, and the collection of vectors is such that the sum of the entries of each vector in the collection is the same value, where the sum is the sum of numerical values, such as voltages or otherwise, of each of the entries.
Notably, the second condition may have an advantage that it makes the voltage code invariant to common leakage of the cells: if the cells leak at the same rate, then the vector read from the cells after leakage also satisfies the second condition above. In certain embodiments, this leads to better refresh properties of the new DRAM architecture, as the refresh intervals may be made longer without running the risk of losing information stored in the cells.
Elements of a voltage code are collectively referred to as “voltage codewords” or simply “codewords” hereinafter. Voltage codes can be used to store information in the following way: where the voltage code has 2n elements, n bits can be used to uniquely address one of the codewords. The operation of computing the codeword of length k from the n bits is referred to as the “encoding operation.” The operation of recovering the n bits from a codeword is referred to as the “decoding operation.” The ratio between n, the number of bits stored, and k, the number of cells used to store those bits, is called the “code rate” of the voltage code, or just “rate.” In applications, a larger rate is typically preferred over a smaller rate, all else being equal.
 FIG. 5 is a schematic diagram illustrating a cell group 435 of memory cells as might be used to store a vector corresponding to a voltage codeword. The vector is stored as k target voltages applied to k memory cells. Cell group 435 comprises k memory cells (one such memory cell 535 is indicated in FIG. 5 with a circle) and each memory cell might comprise a transistor 520 and a capacitor 530 as illustrated. In FIG. 5, k=8, but other values are also possible, as explained elsewhere herein. Also shown in FIG. 5 is one wordline 450 that is coupled to the gates of all of the memory cell's transistor of cell group 435, and bitlines, such as bitline 433, each coupled to a memory cell's transistor.
Suppose the set of possible target voltages is {0.5*Vdd, 0.4*Vdd, 0.3*Vdd, 0} and suppose further that k=4. For the voltage codeword (0, 0.5, 0.4, 0.3), voltages might be written or injected into the associated memory cells, for example, using mixed signal circuitry of storage data encoder circuitry 404, so that a voltage of 0 v is written into a first memory cell of the four cells, a voltage of 0.5*Vdd is written or applied to the second memory cell, a voltage of 0.4*Vdd to the third memory cell, and finally a voltage of 0.3*Vdd to the fourth memory cell in the associated group of memory cells.
When information is read from the cells, storage data read/decoder circuitry 408 receives code data 406 b stored in associated memory cells (the data, in combination, being the codeword of k bits stored in k memory cells) and, based thereon, decodes the codeword to retrieve the original storage data of n bits (storage data 401 b). Storage data read/decoder circuitry 408 includes mixed signal circuitry (which may, in part or in whole, be the same circuitry employed by or in storage data encoder circuitry 404) to generate the codeword of the voltage code from the voltages stored in the associated memory cells and which are sensed by the mixed signal circuitry of storage data read/decoder circuitry 408.
Notably, these values read from the memory cells may be amplified and stored back into the associated memory cells, which may be the situation during a refresh operation, or they may be provided to decoder circuitry of the storage data read/decoder circuitry 408 which may generate and/or output the original n bits of storage data 401 b from the information. In some embodiments, the refresh may also first perform a decoding, and then an encoding operation followed by an application of voltages to the various cells in the group.
The storage data read/decoder circuitry 408 may also include one or more state machines, processors (suitably programmed) and/or field programmable gate arrays (or combinations thereof); indeed, any circuitry (for example, discrete or integrated logic, state machine(s), processor(s) (suitably programmed) and/or field programmable gate array(s) (or combinations thereof)) now known or later developed may be employed to calculate, generate and/or determine the codeword using the storage data. In operation, the storage data read/decoder circuitry may perform or execute one or more applications, routines, programs and/or data structures that implement particular methods, techniques, tasks or operations described and illustrated herein. The functionality of the applications, routines or programs may be combined or distributed. Further, the applications, routines or programs may be implemented by the storage data encoder circuitry using any programming language whether now known or later developed, including, for example, assembly, FORTRAN, C, C++, and BASIC, whether compiled or uncompiled code.
With reference to FIG. 4B, in another embodiment, the DRAM storage device includes, in addition to the conventional elements I/O buffers 420, row decoders 410, memory area 440, word lines 450, and bitlines 433, a column group decoder 430, and a write and read circuit 445 (abbreviated as “Write/Read circuit” hereinafter). The DRAM cells are organized in groups of at least two such cells, as shown in FIG. 5. Each group comprises a number k of cells wherein each cell may comprise one transistor 520 and one capacitor 530. By encoding data as vectors, the contents of each memory cell will likely be not totally independent of the contents of other memory cells in its group. The correlation of information between the cells in a group can be used to store more information on average in every cell.
Upon receiving the bits to be stored, the write/read circuit 445 encodes them into groups of k values. As noted above, these values may not be binary, and in general the vector of k values obtained may belong to a voltage code.
With continued reference to FIG. 4B, the write/read circuit 445 generates the codeword upon receiving n bits of the storage data. The resulting vector may have entries that are non-negative, and at most equal to a given bound, for example the value of the Vdd.
When information is read from the cells, the Write/Read circuit 445 creates a codeword of the voltage code from the sensed voltages. Again, these values may be amplified and stored back, which may be the case during a refresh operation, or they may be forwarded to a decoder circuit which may create the original n bits from the information read. In some embodiments the refresh may also first perform a decoding, and then an encoding operation followed by an application of voltages to the various cells in the group.
Example of a Voltage Code of Rate 4/3
In one embodiment, the storage device employs a voltage code in which the vectors have length 6, and which has 256 elements, thereby allowing the storage of 8 bits into 6 cells. The rate of this voltage code is thus 8/6=4/3.
The elements of this voltage code comprise vectors of the form (a0, . . . , a5)+(b0, . . . , b5) wherein (a0, . . . , a5) is a permutation of the vector (0, 0, 0, ¼, ¼, ¼) and (b0, . . . , b5) is a permutation of the vector (0, 0, 0, ½, ½, ½). The factors ½ and ¼ in the scheme presented here are only for illustrative purposes, and may not be optimal. They can be optimized depending on the parameters of the random variable in Equation 1.
There are 20 vectors of each kind, leading to 400 codewords. To choose 256 of them, we may proceed as follows: for a given vector (x[0], x[1], x[2], . . . , x[7]) we apply the process of FIG. 20 to (x[0], x[1], x[2], x[3]) to obtain a vector (a0, . . . , a5) and we apply the same process to (x[4], x[5], x[6], x[7]) to obtain a vector (b0, . . . , b5). The final vector will then be

¼*(a 0 , . . . ,a 5)+½*(b 0 , . . . ,b 5).

The process of FIG. 20 operates as follows: its input consists of four bits y[0], . . . , y[3]. In Step 2020 three quantities A, B, C are computed as follows

A=y[0]^y[1]^y[2]^y[3]

B=(y[0]&y[1])^(y[2]&y[3])^((y[0]^y[1])&(y[ 2 ]^y[ 3]))

C=y[0]&y[1]&y[2]&y[3]

where “^” denotes the XOR operation, and & is the logical AND. In Step 2030 a determination is made to whether C=0 and at the same time not both A and B are 0. If that is the case, then the bit vector (y[0], y[1], y[2], y[3], B, NAND(A, B)) is output in Step 2050 wherein B is the negation of B, and NAND(A, B) is the NAND of A and B, i.e., (A&B). If the result of the test in Step 2030 was negative, then Step 2040 tests whether the negative test was due to (A, B) being (0, 0) or not. If that was the case, then the vector (1, 1, 0, 0, 1, 0) is output in Step 2060. If that was not the case, then the vector (1, 0, 1, 0, 1) is output in Step 2070.
    A table of values of the process in FIG. 20 is given in FIG. 21. The first four columns in the table corresponds to the four input bits y[0], . . . , y[3]. The next three columns correspond to the value A, B, C computed in the process of FIG. 20, and the final 6 columns correspond to the output vector of that process, denoted by o[0], . . . , o[5].
As an example of the entire process, where the bit sequence (x[0], . . . , x[7])=(1, 0, 0, 1, 1, 1, 0, 0), the process of FIG. 20 is applied first to the bit sequence (x[0], . . . , x[3])=(1, 0, 0, 1) to obtain the output vector (1, 0, 0, 1, 0, 1), and then the process of FIG. 20 is applied to the bit sequence (x[4], . . . , x[7])=(1, 1, 0, 0) to obtain the output (1, 1, 0, 0, 0, 1). The final output is then the vector

¼*(1,0,0,1,0,1)+½*(1,1,0,0,0,1)=(¾,½,0,¼,0,3/4).

The decoding process for this voltage code is implemented by the storage data encoder circuitry. When reading the word (c0, . . . , c5), we may start by determining the positions of the three largest entries. If these positions are denoted by j, k, l, then these positions may determine a vector (v0, . . . , v5) wherein vj=vk=vl=1, and the other entries are zero. If (v4 & v5)=1, then x[4]=x[5]=x[6]=x[7]=v2, and otherwise x[4]=v0, x[5]=v1, x[6]=v2, and x[7]=v3. Next, the vector β/2*(v0, . . . , v5) is subtracted from the vector (c0, . . . , c5) to obtain another vector (d0, . . . , d5), and the positions of the three largest entries of this vector are determined. Here β is a parameter that may depend on the refresh time used in the particular DRAM element using this voltage code. If these positions are denoted by m, n, p, then these positions may determine a vector (w0, . . . , w5) wherein wm=wn=wp=1, and the other entries are zero. If (w4 & w5)=1, then x[0]=x[1]=x[2]=x[3]=w2, and otherwise x[0]=w0, x[1]=w1, x[2]=w2, and x[3]=w3.
    An example is provided by the voltage codeword (¾, ½, 0, ¼, 0, ¾). Using Equation 1 above to model the leakage of the individual cells, and picking for the mean and the standard deviation of the random variable X the values 0.3 and 0.03, for the time t the value of 0.04 seconds (40 milliseconds), and for the parameter α the value 0.5, then the vector read after 0.04 seconds may have been changed to the vector

(c 0 ,c 1 , . . . ,c 5)=(0.358,0.236,0,0.147,0,0.405).

Here we may choose for β the average value of the random variable in Equation 1 after 0.04 seconds which may be calculated to be approximately equal to 0.51. The entries with indices 0, 1, 5 are the largest ones in the read vector, and the vector (v0, . . . , v5) is therefore computed as (1, 1, 0, 0, 0, 1). Since (v4 & v5)=(0 & 0)=0, we obtain x[4]=1, x[5]=1, x[6]=0, x[7]=0. Subtracting β/2*(v0, . . . , v5) from (c0, . . . , c5) leads to the vector

(0.358,0.236,0,0.147,0,0.405)−(0.255,0.255,0,0,0,0.255)=(0.103,−0.019,0,0.147,0,0.15).

    The entries with indices 0, 3, 5 are the largest ones in this vector, and the vector (w0, . . . , w5) is therefore equal to (1, 0, 0, 1, 0, 1). Since (w4 & w5)=(0 & 0)=0, we have x[0]=1, x[1]=0, x[2]=0, x[3]=1. In total, we therefore obtain (x[0], . . . , x[7])=(1, 0, 0, 1, 1, 1, 0, 0) which is indeed equal to the original bit vector.
    Compared to traditional storage of bits on a DRAM, this voltage code has the advantage of higher density. Compared to storage of bits using conventional multilevel DRAM, this encoding technique may have an additional advantage that no external reference is necessary to compare the level of each cell against: in traditional multilevel DRAMs the capacitance of a cell is sensed, converted into a voltage, and then measured against several external references that are pre-charged to the various threshold values of the DRAM. The preparation of the external signals is often rather difficult. In contrast, with the voltage code described in this section, and more generally with all the voltage codes described in this disclosure, there is no need to for an external reference as can be seen in the decoding process described above: in the embodiment of this particular voltage code only the positions of the three largest charges of cells in a group have to be identified; in particular, there is no comparison is needed against a reference.
Example of a Voltage Code of Rate 1.5
In another embodiment, the storage device employs a voltage code in which the vectors have length 4, and which has 64 elements, thereby allowing the storage of 6 bits into 4 cells. The rate of this voltage code is thus 6/4=1.5.
The elements of this voltage code comprise vectors of the form (a0, . . . , a3)+(b0, . . . , b3) wherein (a0, . . . , a3) is a permutation of the vector (0, 0, 1/9, 2/9) and (b0, . . . , b3) is a permutation of the vector (0, 0, ⅓, ⅔). The factors 1/9, 2/9, ⅓, ⅔ in the scheme presented here are only for illustrative purposes, and may not be optimal. They can be optimized depending on the parameters of the random variable in Equation 1.
There are 12 vectors of each kind, leading to 144 codewords. To choose 64 of them, we may proceed as follows: all the memory cells may first be reset to have zero charge. Thereafter, given the vector (x[0], . . . , x[5]), we inject a charge of 2/9 into the cell with index x[0]+2*x[1], a charge of 1/9 into the cell with index (x[0]^x[2])+2*(x[1]^x[2]), add a charge of ⅔ into the cell with index x[3]+2*x[4], and add a charge of ⅓ into the cell with index (x[3]^x[5])+2*(x[4]^[5]). For example, where (x[0], . . . , x[5]) is equal to (1, 0, 1, 1, 1, 0), the charge of cell with index 0 will be 0, the charge of the cell with index 1 will be 2/9+⅓= 5/9, the charge of cell with index 2 will be 1/9, and the charge of the cell with index 3 will be ⅔. The voltage codeword written to the cells is thus equal to (0, 5/9, 1/9, ⅔).
    An embodiment of the decoding process for this voltage code is implemented by the decoding circuitry (for example, of storage data read/decoder circuitry 408 in FIG. 4A). When reading the word (c0, . . . , c3), we may start by determining the position k of the largest entry, and the position l of the second largest entry. We write k as x[3]+2*x[4], thereby determining x[3], x[4]. Next, x[5] is determined as (l^k) mod 2. We then subtract from ck the value 2β/3 and from cl the value β/3 wherein β may be chosen according to the random variable in Equation 1. For example, β could be the mean of this random variable when a certain value is chosen for t. This value may correspond to the refresh time used for refreshing the entries of the DRAM according to this voltage code. For the new vector (c0, . . . , c3) we may determine again the position m of the largest entry, and the position n of the second largest entry. x[0] and x[1] are then determined as m=x[0]+2*x[1], and x[2] may be determined as (m^n) mod 2.
An example is provided by the voltage codeword (0, 5/9, 1/9, ⅔) above. Using Equation 1 above to model the leakage of the individual cells, and picking for the mean and the standard deviation of the random variable X the values 0.3 and 0.03, for the time t the value of 0.04 seconds (40 milliseconds), and for the parameter α the value 0.5, then the vector read after 0.04 seconds may have been changed to the vector

(c 0 ,c 1 ,c 2 ,c 3)=(0,0.276,0.0574,0.356).

The largest entry of this vector is at position k=3=1+2*1, and the second largest entry is at position l=1=1+2*0. We obtain x[3]=x[4]=1. Furthermore, (l^k)=2, so (l^k) mod 2=0. This means that x[5]=0.
Here we may choose for β the average value of the random variable in Equation 1 after 0.04 seconds which may be calculated to be approximately equal to 0.51. We therefore subtract from the vector (c0, c1, c2, c3) the vector (0, 0.51/3, 0, 2*0.51/3)=(0, 0.17, 0, 0.34) and obtain the vector (0, 0.106, 0.0574, 0.016). The largest entry of this vector is at position m=1=1+2*0, and the second largest entry is at position n=2=0+2*1. We therefore obtain x[0]=1 and x[1]=0. Furthermore, (m^n)=3, so x[2]=(m^n) mod 2=1. In total, the bit sequence obtained is (1, 0, 1, 1, 1, 0) which coincides with the original bit sequence.
Compared to traditional storage of bits on a DRAM, this voltage code has the advantage of higher density. As with the previous exemplary embodiment, compared to storage of bits using conventional multilevel DRAM, this encoding technique may have an additional advantage that no external reference is required to compare the level of each cell against: in traditional multilevel DRAMs the capacitance of a cell is sensed, converted into a voltage, and then measured against several external references that are pre-charged to the various threshold values of the DRAM. The preparation of the external signals is often rather difficult. In contrast, with the voltage code described in this section, and more generally with all the voltage codes described in this disclosure, there is no need to for an external reference as can be seen in the decoding process described above: in the embodiment of this particular voltage code only the positions of the three largest charges of cells in a group have to be identified; in particular, there is no comparison is needed against a reference.
Example of a Voltage Code of Rate 1.75
The previous exemplary embodiments can be extended to a voltage code in which the vectors have length 4, and which has 128 elements, thereby allowing the storage of 7 bits into 4 cells. As such, in another embodiment, the storage device may employ a voltage code rate of 7/4=1.75.
As in the previous embodiment, the elements of this voltage code comprise vectors of the form (a0, . . . , a3)+(b0, . . . , b3) wherein (a0, . . . , a3) is a permutation of the vector (0, 0, 1/9, 2/9) and (b0, . . . , b3) is a permutation of the vector (0, 0, ⅓, ⅔). The factors 1/9, 2/9, ⅓, ⅔ in the scheme presented here are only for illustrative purposes, and may not be optimal. They can be optimized depending on the parameters of the random variable in Equation 1.
There are 12 vectors of each kind, leading to 144 codewords of which we choose 128 according to the following process:
    1. The charges of all four cells are initialized to zero. 2. If x[6]=0, then we inject a charge of 2/9 into the cell with index x[0]+2*x[1], a charge of 1/9 into the cell with index (x[0]^x[2])+2*(x[1]^x[2]), add a charge of ⅔ into the cell with index x[3]+2*x[4], and add a charge of ⅓ into the cell with index (x[3]^x[5])+2*(x[4]^x[5]). 3. If x[6]=1 and x[5]=0, then we inject a charge of 2/9 into the cell with index x[0]+2*x[1], a charge of 1/9 into the cell with index (x[0])+2*(x[1]), add a charge of ⅔ into the cell with index x[3]+2*x[4], and add a charge of ⅓ into the cell with index (x[3]^x[2])+2*(x[4]^x[2]). 4. If x[6]=1 and x[5]=1, then we inject a charge of 2/9 into the cell with index x[0]+2*x[1], a charge of 1/9 into the cell with index (x[0]^x[2])+2*(x[1]^x[2]), add a charge of ⅔ into the cell with index x[3]+2*x[4], and add a charge of ⅓ into the cell with index (x[3])+2*(x[4]).   
For example, where (x[0], . . . , x[6]) is equal to (1, 0, 1, 1, 1, 0, 1), we have x[6]=1 and x[5]=0. Therefore, a charge of 2/9 is injected into the cell with index x[0]+2*x[1]=1, a charge of 1/9 into the cell with index (x[0])+2*(x[1])=2, a charge of ⅔ is added to the cell with index x[3]+2*x[4]=3, and a charge of ⅓ is added into the cell with index (x[3]^x[2])+2*(x[4]^x[2])=2. The voltage codeword obtained is therefore (0, 2/9, 4/9, ⅔).
    The decoding process for this voltage code is implemented by the decoding circuitry (for example, of storage data read/decoder circuitry 408 in FIG. 4A) and is similar to the previous embodiment. As before, when reading the word (c0, . . . , c3), we may start by determining the position k of the largest entry, and the position l of the second largest entry. We then subtract from ck the value 2β/3 and from cl the value β/3 wherein β may be chosen according to the random variable in Equation 1. For example, β could be the mean of this random variable when a certain value is chosen for t. This value may correspond to the refresh time used for refreshing the entries of the DRAM according to this voltage code. For the new vector (c0, . . . , c3) we may determine again the position m of the largest entry, and the position n of the second largest entry. We may write k=z[0]+2*z[1], l=u[0]+2*u[1], m=w[0]+2*w[1], and n=v[0]+2*v[1]. From these we obtain x[0], x[1], x[3], x[4], and x[6] directly as

x[0]=z[0],x[1]=z[1],x[3]=w[0],x[4]=w[1],

x[6]=w[0]^w[1]^v[0]^v[1]^u[0]^u[1]^z[0]^z[1].

We may then proceed as follows.
    1. If x[6]=0, then we obtain x[2]=w[0]^u[0], x[5]=z[0]^u[0]. 2. If x[6]=1, then we obtain x[5]=w[0]^w[1]^v[0]^v[1].
         2.1 If x[5]=0, then we obtain x[2]=u[0]^z[0]; 2.2 If x[5]=1, then we obtain x[2]=w[0]^v[0]. 
   
An example is provided by the voltage codeword (0, 2/9, 4/9, ⅔) above. Using Equation 1 above to model the leakage of the individual cells, and picking for the mean and the standard deviation of the random variable X the values 0.3 and 0.03, for the time t the value of 0.04 seconds (40 milliseconds), and for the parameter α the value 0.5, then the vector read after 0.04 seconds may have been changed to the vector

(c 0 ,c 1 ,c 2 ,c 3)=(0,0.11,0.23,0.356).

The largest entry of this vector is at position k=3=1+2*1, and the second largest entry is at position l=2=0+2*1. Here we may choose for β the average value of the random variable in Equation 1 after 0.04 seconds which may be calculated to be approximately equal to 0.51. Subtracting the vector (0, 0, 0.17, 0.34) from (c0, c1, c2, c3) we obtain the vector (0, 0.11, 0.06, 0.016). The largest entry of this vector is at position m=1=1+2*0, and the second largest is at position n=2=0+2*1. We therefore have

z[0]=1,z[1]=1,u[0]=0,u[1]=1,w[0]=1,w[1]=0,v[0]=0,v[1]=1.

It follows that

x[0]=1,x[1]=0,x[3]=1,x[4]=1,x[6]=1.

Further, x[5]=w[0]^w[1]^v[0]^v[1]=0. In this embodiment, x[2]=u[0]^z[0]=1. The final bit sequence is therefore (1, 0, 1, 1, 1, 0, 1) which is equal to the original bit sequence.
Compared to the previous embodiments, this voltage code provides a higher density.
Permutation Modulation Codes
In another embodiment, the device may employ a class of voltage codes which are related to permutation modulation codes and will be referred to as “voltage PM codes” hereinafter. Thus, in these embodiments, the encoder circuitry and decoder circuitry implement one or more voltage PM codes to encode the storage data and decode the encoded storage data, respectively.
Notably, voltage PM codes have several advantages over other types voltage codes. For example, they don't require an absolute reference to determine the values of the bits stored in the memory cells. As such, in certain embodiments implementing voltage PM codes, the device may employ a higher refresh cycle and to lowering the overall energy consumption of the device using such a PM code. Moreover, some voltage PM codes exhibit a large rate, leading to a higher storage density than a conventional DRAM.
In applications, a voltage PM code is a PM code in which the codewords are permutations of a fixed vector a=(x0, x1, . . . , xk−1). This vector is called the “generator” of the voltage PM code. The voltage code is called q-ary if the number of distinct elements of the vector a is q.
Briefly, by way of background, conventional binary voltage PM code may employ the set {(0, 1), (1, 0)} which is a full voltage PM code with generator (0, 1). In one embodiment, the code is used by storing the values of a codeword on two adjacent cells. The decoder circuitry may calculate the difference between the voltage levels of the two cells; if the difference is positive, the bit may be regarded as 1, whereas in the other case the bit may be regarded as 0. An advantage of the use of this type of code is increased reliability of the cells: even when the cell which contains the one discharges heavily, as long as the difference between the cells can be detected, the stored value can be read reliably. A disadvantage of this type of coding is the obvious decrease in the storage density since two cells are needed to store one bit. The density is thus decreased by 50%. Such a method is, for example, disclosed in F errant.
Other binary voltage PM codes can be constructed starting from the binary voltage PM code using the concept of constant weight codes. In this embodiment, the generator of the code (storage data encoder circuitry) is binary, and we may assume that the entries are 0 or 1. For example, the binary voltage PM code may be generated by the vector (1, 1, 1, 0, 0, 0). As is clear to those of moderate skill in combinatorics, this code has 20 elements. An encoder for this code could take 4 bits x[0], x[1], x[2], x[3]. The goal would be to compute a bit vector (a0, . . . , a5). In a first step, we calculate the quantities A, B, C, given as

A=x[0]^x[1]^x[2]^x[3]

B=(x[0]&x[1])^(x[2]&x[3])^((x[0]^x[1])&(x[2]^x[3]))

C=x[0]&x[1]&x[2]&x[3]

where ^ denotes the XOR operation, and & is the logical AND. If C=0 and (A, B) is not (0, 0), then we set the vector (a0, . . . , a5) to (x[0], x[1], x[2], x[3], B, NAND(A, B)), where B is the negation of B, and NAND(A, B) is the NAND of A and B, i.e., (A&B). If A=B=C=0, then we set (a0, . . . , a5) to (1, 1, 0, 0, 1, 0). Otherwise, A=B=0 and C=1. In this embodiment we set (a0, . . . , a5) to (1, 0, 1, 0, 1, 0). The decoding process for this voltage code is implemented by the decoding circuitry (for example, of storage data read/decoder circuitry 408 in FIG. 4A). In this regard, when reading the word (c0, . . . , c5), we may start by determining the positions of the three largest entries. If these positions are denoted by j, k, l, then these positions may determine a vector (v0, . . . , v5) wherein vl=vk vl=1, and the other entries are zero. If (v4 & v5)=1, then x[0]=x[5]=x[6]=x[7]=v2, and otherwise 441=v0, 451=vi, 461=v2, and 471=v3. The determination of the largest three positions can be done in a number of ways. For example, an embodiment may use 15 comparators to compare the values of every ordered pair of positions; these comparisons can easily determine the positions of the largest values.
    This voltage PM code has similar advantages as the conventional binary voltage PM code mentioned above: the cells can decay for a much longer time than for a normal DRAM since comparison of the levels of each cell is not to the fixed reference of Vdd/2; in fact, as long as the values of the cells that are originally equal to 1 are such that the corresponding positions can be determined to contain the largest positions, the decoding process will be successful. As an example, we may suppose that the cells decay according to the process given in Eq. (A) wherein the random variable X may have a mean of 0.19 and a variance of 0.01. Moreover, we assume that the parameter α equals 0.5. These parameters are only examples used for illustrative purposes and no claim is made as to their accuracy in a real process. Similar results as reported below may hold when other numbers are used for the mean and the variance. To fix the example further, we may suppose that the comparators used have a sensitivity of 20 mV. In a normal DRAM, there will be a cell error if the charge of the cell falls below a value of Vdd/2+20 mV. Assuming that Vdd=1V, the probability that this happens is the same as the probability that the value of a zero-mean normal random variable with standard deviation 1 is below (−√{square root over (t)}/ln(0.52)−0.19)/0.01.
To achieve a cell bit error rate of 1e-15, for example, would need a refresh time t of 0.00523 seconds for a standard DRAM. In contrast, for the DRAM implementing a conventional binary voltage PM code, the error probability is equal to the probability that the value of 1 decays to below 20 mV, which means that the error probability is the probability that a zero-mean normal random variable with standard deviation 1 is below (−√{square root over (t)}/ln(0.02)−0.19)/0.01. To have this probability, called q in the following, below 1e-15 requires a refresh rate of t=0.1872 seconds which is more than 35 times larger than for a standard DRAM. The error probability of the voltage PM code above is 1-(1-q)3. To have it below 1e-15 requires a refresh rate t of 0.1827 seconds. If there is an error, then at least one bit in a group of 4 bits will be in error. To have a fair comparison between these codes, we could ask to have groups of 4 bits intact with probability at least 1-1e-15. In this embodiment, we could achieve this with a refresh rate of t=0.1827 seconds for the above voltage PM code, we could achieve this with a refresh rate of t=0.1815 for the voltage code of conventional binary voltage PM code, and we could achieve this with a refresh rate of 0.00507 for the standard DRAM. Therefore, in terms of refresh time the above voltage code has the best value (even better than the code of the conventional binary voltage PM code discussed above) whereas its density is 66% of that of the standard DRAM, i.e., 33% more than the density of the code of such conventional binary voltage PM code.
Very similar results hold if the generator is chosen to be [1, 1, 1, 1, 0, 0, 0, 0]. In this embodiment it is possible to store 6 bits on 8 cells. This code stores 6 bits in 8 cells, hence its density is 75% that of a standard DRAM, and 50% more than that of the aforementioned conventional binary voltage PM code. The refresh time for this code is also more than 35 times larger than that of a standard DRAM.
Embodiments Implementing PM-Type Voltage Codes
As mentioned above, the storage devices may employ voltage PM codes wherein the encoder circuitry and decoder circuitry implement one or more voltage PM codes to encode the storage data and decode the encoded storage data, respectively. In one embodiment, the storage devices employ an n-ary voltage PM code used for storage on volatile memory. Briefly, the input to this procedure of this exemplary embodiment is a target error rate E, the mean μ and the variance σ of the probability distribution in Eq. (A), the parameters a of the distribution, integers l0, . . . , ln−1, a refresh time t and a sensitivity v. The procedure tries to find values x0, . . . , xn−2 such that for a voltage code with generator




a
=




(


x
0

,
…
⁢

 

,

x
0



︸


l
o


|




x
1

,
…
⁢

 

,

x
1


︸


l
1


|
…
|





x

n
-
1


,
…
⁢

 

,

x

n
-
1



)

︸


l

n
-
1








wherein the first group has l0 elements, and the last group has ln−1 elements. The entries of this vector are between 0 and 1, and the last ln−1 entries are all zero. A permutation of this vector is used to store the values on N cells wherein N=l0+ . . . +ln−1. The stored values are denoted by l0, . . . , ln−1. After a time t has elapsed, the values that are read from the cells will be

y 0 e −t  α  /X  0  , . . . ,y N−1 e −t  α  /X  N−1 .

An error is made if there are two indices i and j such that yi>yj but yie−t  α  /X  i <v+yje−t  α  /X  j . The values of x0, x1, . . . , xn−1 are calculated to make the total error less than E.
As mentioned above, the value of xn−1 is set to zero.
Thereafter, the value of xn−2 is calculated in such a way that






l

N
-
2


⁢

Pr
⁡

[



x

n
-
2


⁢

ⅇ


-

t
α


/
X



<
v

]



=

ε

n
-
1






wherein X is a normal Gaussian random variable with mean μ and variance σ and Pr denotes the probability. This is easily seen to be equivalent to






l

n
-
2


⁡

(

1
-


Q
σ

⁡

(



-

t
α


/

ln
⁡

(

v
/

x

n
-
2



)



-
μ

)



)


=

ε

n
-
1






where






Q
σ

⁡

(
x
)


=


1


2
⁢

πσ
2




⁢


∫

-
∞

x

⁢


ⅇ



-


(

s
-
μ

)

2


/
2

⁢

σ
2



⁢

 

⁢


ⅆ
s

.








This means that the value of xn−2 is calculated as





x

n
-
2


=

v
⁢

 

⁢


ⅇ


t
a


μ
+


Q
σ

-
1


⁡

(

1
-

∈


(

n
-
1

)

⁢

l

n
-
2





)





.






Next the value of xn−3 is calculated in such a way as to establish






l

n
-
3


⁢

l

n
-
2


⁢

Pr
⁡

[



x

n
-
3


⁢

ⅇ


-

t
α


/
X



<

v
+


x

n
-
2


⁢

ⅇ


-

t
α


/
Y





]



=

ε

n
-
1






wherein X and Y are independent Gaussian random variables with mean μ and variance σ. This probability is an upper bound on the probability that any of the ln−3 entries in group n−3 of the vector a becomes smaller than any of the ln−2 entries in group n−2 of a. The last equation can be relaxed to the following equation






l

n
-
3


⁢


l

n
-
2


⁡

(

1
-


∫
0
1

⁢



Q
σ

⁡

(


-
μ

-


t
α

/

ln
⁡

(


(

v
+


x

n
-
2


⁢

ⅇ


-

t
α


/


Q
σ

-
1


⁡

(

1
-
s

)






)

/

x

n
-
3



)




)


⁢

 

⁢

ⅆ
s




)



=


ɛ

n
-
1


.





The value of xn−3 can be calculated from this.
The procedure continues in a similar fashion to compute the values of x, for all i from n−4 down to 0. If the value of xi+1 is known, that of xi is obtained from the equation
      l i  ⁢   l  i + 1   ⁡  (  1 -   ∫ 0 1  ⁢    Q σ  ⁡  (   - μ  -   t α  /  ln ⁡  (   (  v +   x  i + 1   ⁢  ⅇ   -  t α   /   Q σ  - 1   ⁡  (  1 - s  )       )  /  x i   )     )   ⁢     ⁢  ⅆ s     )    =   ɛ  n - 1   .     
Exemplary Voltage PM Codes

In the exemplary coding techniques (which are employed by the encoder circuitry and decoder circuitry) described below, we choose ε=10−15, μ=0.19, σ=0.01, α=0.5. The refresh time τ for a standard DRAM with these settings is 0.005229 seconds, as was shown above. The refresh time needed for the DRAM using the voltage PM codes given below is given as a multiple r of τ, i.e., t=rτ.
The parameters employed here are only for illustrative purposes. Other values for these parameters can be chosen and similar results can be obtained. All parameters consistent with this description may be employed and, as such, the coding techniques resulting therefrom are intended to fall within the scope of the present inventions. The various embodiments are identified by the number of bits stored in a cell group and the number of cells in the group. Thus, 8B6C identifies an embodiment storing eight bits in a six cell memory group.
8B6C: In this embodiment, the generator a is of the form a=(x, y, z, u, 0, 0), wherein the parameters x, y, z, u are distinct and may be determined in such a way as to optimize the code with respect to some cost function. For example, where the cost function is the refresh time needed, and the objective is to maximize this time, a may be chosen as a=(0.992371, 0.491736, 0.223515, 0.07643, 0, 0). In this embodiment r=4.15, which means that the refresh time for the corresponding DRAM will be 4.15 times larger than that of a standard DRAM. There are 360 different permutations of the vector a, so 8 bits can be encoded into this codebook. The bits can be encoded into a permutation in a variety of ways. For example, in one embodiment, a table lookup can be used. In another embodiment, circuitry that encodes/decodes a byte into a permutation may be employed in the encoder circuitry and decoder circuitry. Other variations or embodiments may also be employed.
The density of this design is 8/6=1.33, which means that with this design the density is improved by 33% while the refresh time is increased by a factor of 4.15. Since during this refresh time 1.33 times more cells are refreshed, the amount of energy used by the refresh operation is in fact 4.15*4/3 times less, i.e., the refresh energy used is 5.533 times less than that of a standard DRAM.
8B8C: In this embodiment the generator a is of the form a=(x, x, y, y, 0, 0, 0, 0), wherein the parameters x, y are distinct and may be determined in such a way as to optimize the code with respect to some cost function. For example, where the cost function is the refresh time needed, and the objective is to maximize this time, a may be chosen as a=(0.976712, 0.976712, 0.234784, 0.234784, 0, 0, 0, 0). In this embodiment r=14, which means that the refresh time for the corresponding DRAM will be 14 times larger than that of a standard DRAM. There are 420 different permutations of the vector a. 8 bits can be encoded into this codebook using for example the methods taught in Cronie-2. This means that the density of this voltage code DRAM is the same of that of a standard DRAM while its refresh time is 14 times larger.
15B10C: In this embodiment the generator a is of the form a=(x, y, z, z, z, u, u, u, 0, 0), wherein the parameters x, y, z, u are distinct and may be determined in such a way as to optimize the code with respect to some cost function. For example, where the cost function is the refresh time needed, and the objective is to maximize this time, a may be chosen as a=(0.984720, 0.491025, 0.222455, 0.222455, 0.222455, 0.075221, 0.075221, 0.075221, 0, 0). In this embodiment r=4.05, which means that the refresh time for the corresponding DRAM will be 4.05 times larger than that of a standard DRAM. There are 50400 different permutations of this vector which means that we can encode 15 bits into the corresponding codebook. In one embodiment, for example, a table lookup is executed in conjunction with methods disclosed in Cronie-2. This means that the density of the voltage code DRAM is 50% more than that of a standard DRAM while its refresh time is more than 4 times larger. Since during this refresh time 1.5 times more cells are refreshed, the amount of energy used by the refresh operation is in fact 4.05*1.5 times less, i.e., the refresh energy used is 6.075 times less than that of a standard DRAM while the density is 50% larger.
18B10C: In this embodiment the generator a is of the form a=(x, y, z, u, w, w, t, t, 0, 0), wherein the parameters x, y, z, u, w, t are distinct and may be determined in such a way as to optimize the code with respect to some cost function. For example, where the cost function is the refresh time needed, and the objective is to maximize this time, a may be chosen as a=(0.983564, 0.629365, 0.386984, 0.225519, 0.117969, 0.117969, 0.046942, 0.046942, 0, 0). In this embodiment r=1.68, which means that the refresh time for the corresponding DRAM will be 1.68 times larger than that of a standard DRAM. There are 453600 different permutations of this vector which means that we can encode 18 bits into the corresponding codebook. This embodiment may be implemented, for example by combining a table lookup with methods disclosed in Cronie-2. This means that the density of the voltage code DRAM is 80% more than that of a standard DRAM while its refresh time is 1.68 times larger. Since during this refresh time 1.8 times more cells are refreshed, the amount of energy used by the refresh operation is in fact 1.68*1.8 times less, i.e., the refresh energy used is 3.024 times less than that of a standard DRAM while the density is 80% larger.
Exemplary High Level Architecture of Dram Elements Utilizing Voltage PM Codes
An exemplary high level architecture of the Write/Read circuits of 447 of FIGS. 4A and 4B is now given with reference to FIG. 6 and FIG. 7 for the embodiments where a voltage PM code is employed in the encoder and decoder circuitry. Specifically, in FIG. 6, the bits b[0], . . . , b[K−1] to be stored are given to a ranking encoder circuit 620. A task of ranking encoder circuit 620 is to produce ranking information. In operation, where the code generator a equals a=(x0, x1, . . . , xk−1), where x0≧x1≧ . . . ≧xk−1 and xm=xm+1= . . . =xk−1=0, the ranking information may be operationally equivalent to a vector v=(v[0], v[k−m−]) which may mean that cells with indices v[i] will have charge equivalent to x1 for i=0, . . . , k−m−1, while all the other cells have charge 0. This vector may be used to the cell load circuit 630 to put the charges into the corresponding cells 435 of FIGS. 4A and 4B.
 FIG. 7 shows an exemplary architecture of a read circuit when voltage PM codes are used. Specifically, charges from the cells 435 of FIGS. 4A and 4B are read by a charge read circuit 750. These charges may be translated by this circuit into other physical quantities, such as voltages, and these quantities are forwarded in form of a vector to a ranking circuit 740. Where the vector forwarded to the ranking circuit is (x0, x1, . . . , xk−1), where the j-th entry of this vector is a description of the charge level of the j-th cell, the output of the ranking circuit may be a permutation π=(π(0), . . . , π(k−1)) of the integers 0, 1, . . . , k−1 such that xπ(0)≧xπ(1)≧ . . . ≧xπ(k−1), meaning that the cell with index π(0) has the largest charge, the cell with index π(1) has the second largest charge, etc.
Notably, where the 8B8C code introduced above is used, the positions of the cells with the two largest values, and the positions of the cells with the two second largest values may be sufficient to decode the codeword. After the ranking circuit 740 has created its output, this output is forwarded to a ranking decoder 720 which uses the output of the ranking circuit to produce the bits b[0], . . . , b[K−1]. Some examples of these circuits will be provided later.
Using the write and read circuits of FIG. 6 and FIG. 7, it is also possible to describe a possible refresh operation for a DRAM using voltage PM codes. This is done with reference to FIG. 8. In this embodiment, the read operation of FIG. 7 is applied to recover the storage data bits stored in a group of cells 435, and then these bits are used by the write circuit of FIG. 6 to store the corresponding charges back into the memory cells of the memory area.
Notably, in those embodiments where the encoder and/or decoder circuitry employ ranking and/or sorting techniques, the encoder and/or decoder circuitry may implement any or all of the circuitry and techniques described in Cronie-3.
Exemplary Operation of Ranking Encoder and Ranking Decoder
For the code 8B6C given above, the generator a is of the form a=(x, y, z, u, 0, 0) wherein x, y, z, u are distinct. One embodiment of a possible ranking encoder 620 of FIG. 6 is now described with reference to FIG. 9. The input to this module are 8 bits b[0], . . . , b[7], and the output is a vector v=(v[0], v[1], v[2], v[3]) of integers in {0, 1, 2, 3, 4, 5}. Operationally, this may mean that the cell load circuit 630 needs to put a charge of x on the cell with index v[0], a charge of y on the cell with index v[1], a charge of z on the cell with index v[2], and a charge of u on the cell with index v[3]. A flowchart of an exemplary process employed by the ranking encoder circuit is given in FIG. 9. Specifically, in Step 920 an integer M is calculated whose binary expansion if b[0], . . . , b[7], and a set S is initialized to {0, 1, 2, 3, 4, 5}. It is understood that the set S comes with an ordering of its elements from lowest to largest. Thereafter, in Step 930 the value of v[0] is calculated as floor(M/60), wherein floor(x) for a real number x is the smallest integer less than or equal to x. So, for example, floor(1.2)=1, and floor(2.34)=2. The element v[0] is removed from the set S, and the value of M is updated to M mod 60, i.e., the remainder of M after division by 60. In Step 940 the second entry v[1] of the vector v is calculated as S[floor(M/12)], the element v[1] is removed from S, and the value of M is updated to M mod 12. In Step 950 the third entry v[2] of the vector v is calculated as S[floor(M/3)], the element v[2] is removed from S, and the value of M is updated to M mod 3. In Step 960 the final value v[3] of v is calculated as SM.
As will be clear to those of moderate skill in the art, the values v[0], . . . , v[3] will always be distinct, and will be integers in the set {0, 1, 2, 3, 4, 5}.
An example is now provided for the embodiment where the input vector is (b[0], . . . , b[7])=(0, 1, 1, 0, 1, 1, 0, 1). In this embodiment, the number M is calculated in Step 920 as M=182 and S is initialized to {0, 1, 2, 3, 4, 5}. In Step 930 v[0] is calculated as floor(182/60)=3, and S becomes {0, 1, 2, 4, 5}. Moreover, M becomes M mod 60=2. Since floor(M/12)=0, the value of v[1] is calculated to be S[0]=0 in Step 940, S is updated to {1, 2, 4, 5}, and M is updated to M mod 12=2. The value of v[2] is computed as S[0]=1 in Step 950, S is updated to {2, 4, 5}, and M keeps its value 2. Finally, the value of v[3] is S[2]=5, so that (v[0], . . . , v[3])=(3, 0, 1, 5).
An exemplary operation of the ranking decoder circuit of FIG. 7 is now described. In this embodiment the ranking circuit 740 of FIG. 7 may have produced a vector (π(0), π(1), π(2), π(3)), which may mean that the cell with index π(0) has the largest charge, the cell with index π(1) has the second largest charge, etc. Upon receiving this vector, the circuit may calculate a number M as
     M =   ∑  j = 0  3  ⁢   τ ⁡  [ j ]   ⁢  (    π ⁡  [ j ]   -  |  {   i < j  |   π ⁡  [ i ]   <  π ⁡  [ j ]     }  |  )     ,    
where (τ[0], τ[1], τ[2], τ[3])=(60, 12, 3, 1). Thereafter, the bits b[0], . . . , b[7] may be obtained from the binary expansion of M: M=b[0]+b[1]+ . . . +128b[7].

As an example, consider the embodiment where the input to the ranking decoder is (π[0], π[1], π[2], π[3])=(3, 0, 1, 5), i.e., the output of the ranking encoder example above. This means that the largest charge is to be put in cell with index 3, the second largest into cell with index 0, etc. From this vector we calculate the value M according to the following formula:

j=0→π[0]−|{i<0|π[i]<π[0]}|=π[0]=3

j=1→π[1]−|{i<1|π[i]<π[1]}|=π[1]=0

j=2→π[2]−|{i<2|π[i]<π[2]}|=π[2]−1=0

j=3→π[3]−|{i<3|π[i]<π[3]}|=π[3]−3=2

We therefore obtain M=3*60+0*12+0*3+2=182, from which we obtain the bits (b[0], . . . , b[7])=(0, 1, 1, 0, 1, 1, 0, 1) through binary expansion.

Full Voltage PM Codes and Exemplary Procedures of the Ranking Encoder and Ranking Decoder

A “full voltage PM code” is a voltage PM code in which the coordinates of the generator a are all distinct. As is clear to those of skill in the art, among all possible voltage PM codes of length k, the rate of a full voltage PM code is the largest possible. Moreover, a full voltage PM code of length n is necessarily n-ary.
We describe the operation of the ranking encoder circuit 620 and the ranking decoder circuit 720 for full voltage PM codes. For ease of presentation we will assume that the length of the generator (and the number of cells) is a power of 2: K=k=2m.
The input of the ranking encoder process is a vector b=(b[0], . . . , b[N−1]) where N=mK/2. So, for example, when K=8. Then N=12. The output of the ranking encoder process is a permutation (π(0), π(1), . . . , π(K−1)) of the set {0, 1, 2, . . . , K−1}. The ranking encoder process is described by a procedure given in the pseudocode listing of FIG. 18. The Swap(.) function in the pseudocode listings exchanges or swaps its arguments.
The ranking decoder process receives a permutation (π(0), π(1), . . . , π(K−1)) and creates N bits b[0], . . . , b[N−1] according to the process given in the pseudocode of FIG. 19, where π(j+k)[i] is the i-th least significant bit of the integer π(j+k).
The loops given above can be optimized and unrolled for any specific value of K. One such example is given with reference to FIG. 10 and FIG. 12. Specifically, FIG. 10 describes an exemplary process for the rank encoder circuit where K=8. The circles in this figure correspond to the values of the entries of the permutation vector π. Read from top to bottom, the values in the circles will be equal to (π(0), . . . , π(K−1)) at every point in the process. For example, at the beginning of the process, corresponding to the circles 1010 in the left most column, the bit representation of π(0) is 000, that of π(1) is 001, etc., corresponding to the initial value of the permutation being equal to (0, 1, . . . , 7). In a first level, the bits b[0], . . . , b[3] are used in conjunction with four SWAP circuits 1020 to produce a first transformation of the permutation η given in the second column of circles. The task of the SWAP circuits 1020 is further described in FIG. 11A: they swap the least significant bits of their arguments if the corresponding bit is 1. As an example, if b[0]=b[3]=1, and b[1]=b[2]=0, then the first SWAP circuit 1020 swaps the least significant bits of its arguments 000 and 001, which means that the values of the first two circles in the second column are 001 and 000. The same is true for the last pair of value of π, so that the values of the last two circles are 111 and 110. Altogether, the entries of the second set of circles are, read from top to bottom, equal to 001, 000, 010, 011, 100, 101, 111, and 110. Note that the circuits 1020 operationally swap their arguments entirely if the corresponding bit is 1. However, they do the swap only on the least significant bit to save on the number of operations.
Assume now that b[4]=1, b[5]=0, b[6]=b[7]=1. The circuits 1030 described in FIG. 11B swap the two least significant bits of their arguments if the corresponding bit is 1. Therefore, the values of the circles in the third column are 010, 000, 001, 011, 111, 110, 100, 101.
As a matter of example, assume that b[8]=b[10]=b[11]=1, and b[9]=0. The SWAP circuits 1040 described in FIG. 11C completely swap the values of their arguments. In this embodiment, the output of the rank encoder circuitry (which may be storage data encoder circuitry 404), given by the values of the last column of circles in FIG. 10, will be 111, 000, 100, 101, 010, 110, 001, 011, leading to the permutation

π=(7,0,4,5,2,6,1,3).

An unrolled version of the rank decoding procedure outlined above in pseudocode is now explained for the embodiment where K=8 with reference to FIG. 12. As can be seen by the reader, this procedure is similar to the rank encoding procedure given in FIG. 10. One of the differences is, however, that while the flow of data in FIG. 10 was from left to right, the flow of data in FIG. 12 is from right to left. The input to this procedure is a permutation π=(π(0), . . . , π(7)), given in the cells 1210 in the right most column. In general, the circles in this figure correspond to the values of the entries of the permutation vector π. Read from top to bottom, the values in the circles will be equal to (π(0), . . . , π(K−1)) at every point in the process. This process also makes use of 12 conditional swap circuits 1230. Such a circuit is detailed in FIG. 13, and accepts three inputs and three outputs. Two of the inputs, given as a and b, are integers in {0, 1, 2, 3, 4, 5, 6, 7}, and one of the inputs, given as k, is an integer in {0, 1, 2}. For arbitrary values of K, the inputs a and b belong to the set {0, 1, . . . , K−1}, and the input k belongs to the set {0, 1, . . . , m−1} where K=2m. The operation of the conditional swap circuit is explained in FIG. 13; Its output, x, equals the k-th least significant bit of its first input a. If this bit is zero, then its first output c equals a and its second output d is b. If this bit is one, then the inputs are swapped, i.e., the first output is b and the second output is d. Returning to FIG. 12, the conditional swap circuits reveal the bits b[0], . . . , b[11] one by one, but in reverse order, and conditionally swap the values of their first and second inputs depending on the value of these bits.
As an example, consider the permutation π=(7, 0, 4, 5, 2, 6, 1, 3) from the previous example. They correspond to the binary representations 111, 000, 100, 101, 010, 110, 001, 011. The first condition swap circuit compares 111 and 010. Sine bit 2 of the first input 111 is 1, it swaps these inputs and reveals the value of b[8] as 1. The second conditional swap circuit compares the inputs 000 and 110. Bit 2 of the first input is 0, so b[9]=0, and the inputs are not swapped. Similarly, the third conditional swap circuit compares 100 and 001, deduces that b[10]=1, and swaps the values. The fourth conditional swap circuit compares 101 and 011, deduces b[11]=1, and swaps its inputs. Therefore, the values of the second set of circles from the right in FIG. 12, reading from top to bottom, will be 010, 000, 001, 011, 111, 110, 100, 101. To obtain the value of b[4], the corresponding conditional swap circuit compares the values of 010 and 001. Bit 1 of the first input is 1, so b[4]=1 and the inputs are swapped. In a similar manner, b[5]=0, and the inputs are not swapped, b[6]=1 and the inputs are swapped, and b[7]=1 and the inputs are swapped. The values of the third set of circles from the right, read from top to bottom, will therefore be 001, 000, 010, 011, 100, 101, 111, 110. To obtain b[0], the first two entries 001 and 000 are compared. Bit 2 of the first input is 1, so b[0]=1, and the entries are swapped. Similarly, b[1]=0 and the inputs are not swapped, b[2]=0 and the inputs are not swapped, and b[3]=1 and the inputs are swapped. The entries in the first set of circles from the left will be 000, 001, 010, 011, 100, 101, 110, 111 and the recovered bit sequence is (1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1) which is equal to the original bit sequence.
It should be noted that applying lower voltages to the memory cells to store data translates to spending lower energy on charging the cells to the appropriate levels. For example, using as a proxy of the energy the square of the Euclidean norm of the generator of the voltage PM code, in conventional DRAM storage the energy would be on average ½ per cell. For the embodiments implementing the voltage PM codes in this disclosure, the energy can be substantially lower—for example, the voltage PM code 8B8C exhibits a static energy reduction/improvement of almost a factor of 4. Moreover, the codes can be optimized for static energy usage, or a combination of dynamic and static energy usage.
There are many embodiments described and illustrated herein. While certain embodiments, features, attributes and advantages have been described and illustrated, it should be understood that many others, as well as different and/or similar embodiments, features, attributes and advantages of the present invention, are apparent from the description and illustrations. As such, the above embodiments of the inventions are merely exemplary. They are not intended to be exhaustive or to limit the inventions to the precise forms, techniques, materials and/or configurations disclosed. Many modifications and variations are possible in light of this disclosure. It is to be understood that other embodiments may be utilized and operational changes may be made without departing from the scope of the present inventions. As such, the scope of the inventions is not limited solely to the description above because the description of the above embodiments has been presented for the purposes of illustration and description.
Importantly, the present inventions are neither limited to any single aspect nor embodiment, nor to any combinations and/or permutations of such aspects and/or embodiments. Moreover, each of the aspects of the present inventions, and/or embodiments thereof, may be employed alone or in combination with one or more of the other aspects and/or embodiments thereof. For the sake of brevity, many of those permutations and combinations will not be discussed and/or illustrated separately herein.
For example, in one embodiment, the voltage code implemented by the encoder circuitry to encode the storage data (and by the decoder circuitry to decode and recover the storage data) may be fixed or programmable, for example, one time programmable (for example, programmed during test or at manufacture) or more than one time programmable (for example, during test, start-up/power-up, during an initialization sequence and/or during operation of the circuitry or device (for example, in situ)).
With reference to FIG. 14, in one embodiment, the device may include voltage code program circuitry to store information which is representative of the desired voltage code to be implemented by the storage data encoder circuitry and the storage data read/decoder circuitry. In one embodiment, the voltage code program circuitry includes a register or the like to store the desired voltage code to be implemented by the storage data encoder circuitry and the storage data read/decoder circuitry.
In another embodiment, the voltage code program circuitry may include fuses or anti-fuses, DRAM, SRAM, ROM, PROM, EPROM, EEPROM and/or flash memory cells, to store data which is representative of the voltage code for use by the storage data encoder circuitry and the storage data read/decoder circuitry. In one embodiment, the data which is representative of the voltage code to be implemented may be provided to the storage data encoder circuitry and the storage data read/decoder circuitry, for example, at start-up/power-up, during an initialization sequence, by external integrated circuit device and/or in response to one or more user or operator instructions or inputs. Indeed, in one embodiment, the voltage code may be determined at start-up/power-up, during an initialization sequence, by external circuitry and/or in response to user or operator instructions based on information that is representative of the output data length (for example, ×4, ×8 or ×16) and thereafter the voltage code which, for example, is most efficient for the output data length, is provided to the storage data encoder circuitry and the storage data read/decoder circuitry.
For example, where the output data length is ×4, ×8 or ×16, it may be advantageous to employ a rate of voltage code of 1.5 wherein the storage data encoder circuitry generates a codeword of length 4 from 6 bits of storage data. That is, a voltage code in which the vectors have length 4, and which has 64 elements, thereby allowing the storage of 6 bits into 4 cells. The rate of this voltage code is thus 6/4.
Notably, the memory (for example, register) may be a permanent, semi-permanent or temporary (i.e., until re-programmed) storage; for example, a DRAM, SRAM, ROM, PROM, EPROM, EEPROM and/or Flash memory cells that are resident on (i.e., integrated in) the interface circuitry, device or system, or external thereto (i.e., not integrated in). Indeed, the voltage code for the storage data encoder circuitry and the storage data read/decoder circuitry may be defined via a particular fixed configuration of the state of switch(es) or certain pin(s) on the package of the device (which may be, for example, defined or established during manufacturing). All circuitry and techniques of (i) storing scaling information and/or (ii) programming the storage data encoder circuitry and the storage data read/decoder circuitry during before or during operation are intended to fall within the scope of the present invention.
Further, as noted above, the dynamic random access memory may be implemented in a discrete type configuration/architecture (for example, a stand-alone memory device—see FIG. 16A) and/or embedded type configuration/architecture (for example, an integrated circuit device having logic circuitry and one or more dynamic random access memory cells and/or arrays incorporated therein or thereon—see FIG. 16B). Moreover, one or more aspects of the circuitry and techniques described herein (for example, the encoding and/or decoding circuitry and techniques) may be implemented in circuitry which is located “off-chip” relative to the discrete type and/or embedded type configuration/architectures. (See, for example, FIGS. 17A-17C). Physical configurations or architectures that implement the techniques described herein are intended to fall within the scope of the present invention.
Notably, the embodiments disclosed herein may exhibit one or more of the following attributes:
1. Longer refresh cycles relative to conventional DRAMs: lower dynamic energy.
2. Lower energy to write the cells relative to conventional DRAMs: lower static energy.
3. Higher density relative to conventional DRAMs.
4. Robustness to imperfections: it is not necessary to hit the exact values of the generator a. Moreover, imperfections of these values can be taken into account when designing the voltage PM code. This leads to a more robust operation.
Combination with an Outer ECC
In one embodiment, the circuitry and techniques may be combined with an outer error-correcting code (ECC) to provide a higher reliability of the memory cells. An exemplary embodiment is described with reference to FIGS. 15A and 15B. Specifically, in FIG. 15A, write circuit 447 of FIG. 4B may comprise an Outer Encoder circuit 1420 whose task is to encode the input bits using an outer error-correcting code. The outer error-correcting code can be a binary code, or it can be a code defined over a larger alphabet, for example a Reed-Solomon code, or an algebraic geometry code, in order to provide better resilience to errors. Once the outer encoder circuit 1420 has encoded the bits, these bits are forwarded to the ranking encoder circuits 1430 for the computation of encoded information that will be eventually stored in the cells. Similarly, in FIG. 15B, ranking decoders 1450 decode the received information into bits, or sequences of bits, and these bits are forwarded to the outer decoder 1440 which calculate the output bits. The outer decoder may be part of the write/read circuit 447 of FIG. 4B in some embodiments.
An example of an outer ECC is now provided with reference to the code 8B6C above. The outer encoder may take some number L of bytes (wherein each byte comprises eight bits) and encode these L bytes using a Reed-Solomon code of length T over GF(256). These 8T bits are grouped into T groups of size 8, and each group is then fed to the rank encoder of the 8b6C code. The combined cell efficiency of this scheme is 4 L/3 T, and the outer coding can provide resilience to up to (T−L)/2 errors on groups of 6 cells.
The above description is exemplary and illustrative and is not meant to be restrictive. Many other methods and combinations of ECC schemes with encoders according to the various embodiments are possible and will become apparent to those of moderate skill in the art upon study of this disclosure. For example, the outer code may be a binary code with an efficient encoding and decoding procedure, such as an LDPC code. Or it may be a code derived from curves on a finite field (AG-code), or another type of code well suited for the application in memory storage. The application claims priority on all such schemes as well.
It should be noted that the term “circuit” may mean, among other things, a single component or a multiplicity of components, which are active and/or passive, and which are coupled together to provide or perform a desired function. The term “circuitry” may mean, among other things, a circuit, a group of such circuits, one or more processors, one or more state machines, one or more processors implementing software, one or more gate arrays, programmable gate arrays and/or field programmable gate arrays, or a combination of one or more circuits (whether integrated or otherwise), one or more state machines, one or more processors, one or more processors implementing software, one or more gate arrays, programmable gate arrays and/or field programmable gate arrays. The term “data” may mean, among other things, a current or voltage signal(s) whether in an analog or a digital form, which may be a single bit (or the like) or multiple bits (or the like).
It should be further noted that the various circuits and circuitry disclosed herein may be described using computer aided design tools and expressed (or represented), as data and/or instructions embodied in various computer-readable media, for example, in terms of their behavioral, register transfer, logic component, transistor, layout geometries, and/or other characteristics. Formats of files and other objects in which such circuit expressions may be implemented include, but are not limited to, formats supporting behavioral languages such as C, Verilog, and HLDL, formats supporting register level description languages like RTL, and formats supporting geometry description languages such as GDSII, GDSIII, GDSIV, CIF, MEBES and any other suitable formats and languages. Computer-readable media in which such formatted data and/or instructions may be embodied include, but are not limited to, non-volatile storage media in various forms (e.g., optical, magnetic or semiconductor storage media) and carrier waves that may be used to transfer such formatted data and/or instructions through wireless, optical, or wired signaling media or any combination thereof. Examples of transfers of such formatted data and/or instructions by carrier waves include, but are not limited to, transfers (uploads, downloads, e-mail, etc.) over the Internet and/or other computer networks via one or more data transfer protocols (e.g., HTTP, FTP, SMTP, etc.). The embodiments described are also directed to such representation of the circuitry described herein (for example, storage data encoder circuitry and the storage data read/decoder circuitry), and/or techniques implemented thereby, and, as such, are intended to fall within the scope of the present inventions.
Indeed, when received within a computer system via one or more computer-readable media, such data and/or instruction-based expressions of the above described circuits may be processed by a processing entity (e.g., one or more processors) within the computer system in conjunction with execution of one or more other computer programs including, without limitation, net-list generation programs, place and route programs and the like, to generate a representation or image of a physical manifestation of such circuits. Such representation or image may thereafter be used in device fabrication, for example, by enabling generation of one or more masks that are used to form various components of the circuits in a device fabrication process.
Moreover, the various circuits and circuitry, as well as techniques, disclosed herein may be represented via simulations and simulation instruction-based expressions using computer aided design, simulation and/or testing tools. The simulation of the circuitry described herein, including the storage data encoder circuitry and the storage data read/decoder circuitry and/or techniques implemented thereby, may be implemented by a computer system wherein characteristics and operations of such circuitry, and techniques implemented thereby, are simulated, imitated, replicated, analyzed and/or predicted via a computer system. Simulations and testing of the devices and/or circuitry described herein, and/or techniques implemented thereby, and, as such, are intended to fall within the scope of the present inventions. The computer-readable media and data corresponding to such simulations and/or testing tools are also intended to fall within the scope of the present inventions.

We claim:
 
1. An apparatus comprising:
a memory area comprising a plurality of cell groups of k memory cells in each cell group, wherein k is an integer greater than one;
a row and column decoder circuit coupled to the memory area and configured to select at least one cell group;
a storage data encoder circuit configured to encode an n-bit value, for an n>k, received at a data input into a k-entry codeword of a voltage code, the k-entry codeword representing (i) a selection of a first permutation vector based on a first half of the n-bit value and a second permutation vector based on a second half of the n-bit value, wherein the first and second permutation vectors are weighted with first and second weights, respectively, and (ii) an element-by-element summation of the first and second permutation vectors, wherein each entry in the k-entry codeword is one of three possible entry values; and
a cell-load unit configured to store the k-entry codeword as levels in the at least one selected cell group.


  
2. The apparatus of claim 1, wherein a summation of the k entries of each k-entry codeword in at least a subset of the set of possible k-entry codewords is equal to a predetermined constant over the subset.

  
3. The apparatus of claim 1, wherein the apparatus is a device selected from the group consisting of: an integrated circuit device, a discrete memory device, and a device having embedded memory.

  
4. The apparatus of claim 1, wherein the memory cells comprise circuit elements configured to store the k-entry codeword as a plurality of electrical quantities, the k-entry codeword selected from a set of at least 2n distinct possible k-entry codewords.

  
5. The apparatus of claim 4, wherein the memory cells comprise a plurality of capacitors, and wherein the electrical quantities are charges stored on the plurality of capacitors.

  
6. The apparatus of claim 1, wherein the storage data encoder circuit is configured to form a first set of permutation selection quantities from the first half of the received n-bit value and a second set of permutation selection quantities from the second half of the received n-bit value.

  
7. The apparatus of claim 6, wherein the storage data encoder circuit comprises a logic circuit configured to implement Boolean algebra to form the first and second sets of permutation selection quantities.

  
8. The apparatus of claim 1, wherein the storage data encoder circuit processes the first half of the n-bit value and the second half of the n-bit value to identify indices of the first and second permutation vectors, respectively.

  
9. The apparatus of claim 1, wherein the storage data encoder circuit comprises a ranking encoder.

  
10. The apparatus of claim 1, further comprising a storage data decoder circuit configured to reconstruct an n-bit read value from a k-entry vector read from a selected read cell group by forming a k-length intermediate vector comprising information about relative magnitudes of the elements of the read k-entry vector, the k-length intermediate vector determining a second half of the n-bit read value, forming a k-length difference vector by subtracting a weighted version of the k-length intermediate vector from the read k-entry vector, the k-length difference vector determining a first half of the n-bit read value, the storage data decoder circuit configured to output the reconstructed n-bit read value.

  
11. An apparatus comprising:
a memory area comprising a plurality of cell groups of k memory cells in each cell group, wherein k is an integer greater than one;
a row and column decoder circuit coupled to the memory area and configured to select a cell group;
a charge-read unit configured to read a k-entry vector as charge levels from the k-memory cells of the selected cell group; and
a storage data decoder circuit configured to reconstruct an n-bit read value from the k-entry vector read from the selected cell group, for an n>k, by forming a k-length intermediate vector comprising information about relative magnitudes of the elements of the read k-entry vector, the k-length intermediate vector determining a second half of the n-bit read value, forming a k-length difference vector by subtracting a weighted version of the k-length intermediate vector from the read k-entry vector, the k-length difference vector determining a first half of the n-bit read value, the storage data decoder circuit configured to output the reconstructed n-bit read value.


  
12. The apparatus of claim 11, wherein the storage data decoder circuit is a ranking decoder.

  
13. The apparatus of claim 12, wherein the k-length intermediate vector comprises (i) a logic 1 in positions corresponding to positions of the read k-entry vector having largest relative magnitudes and (ii) logic zeroes in other positions.

  
14. The apparatus of claim 13, wherein the storage data decoder circuit comprises a logic circuit configured to implement Boolean algebra on the k-length intermediate vector to determine the second half of the n-bit read value.

  
15. The apparatus of claim 12, wherein the k-length intermediate vector comprises (i) respective ordered magnitude indicators in positions corresponding to positions of the read k-entry vector having largest relative magnitudes and (ii) logic zeroes in other positions.

  
16. The apparatus of claim 11, wherein the storage data decoder circuit further comprises a logic circuit configured to form quantities by implementing Boolean algebra on the k-length intermediate vector, and to use the quantities to determine the second half of the n-bit read value.

  
17. The apparatus of claim 11, wherein the storage data decoder circuit further comprises a logic circuit configured to form quantities by implementing Boolean algebra on the k-length intermediate vector, and to use the quantities to determine the first half of the n-bit read value.

  
18. The apparatus of claim 11, wherein the weighted version of the k-length intermediate vector comprises weights based on at least one system parameter selected from the group consisting of a refreshed interval parameter, a decay time constant parameter, and a process variation parameter.

  
19. The apparatus of claim 11, further comprising:
a storage data encoder circuit configured to encode an n-bit write value received at a data input into a k-entry codeword of a voltage code, the k-entry codeword representing (i) a selection of a first permutation vector based on a first half of the n-bit write value and a second permutation vector based on a second half of the n-bit write value, wherein the first and second permutation vectors are weighted with first and second weights, respectively, and (ii) an element-by-element summation of the first and second permutation vectors, wherein each entry in the k-entry codeword is one of three possible entry values; and
a cell-load unit configured to store the k-entry codeword as levels in at least one selected write cell group of the memory area.


  
20. The apparatus of claim 19, wherein the storage data encoder circuit comprises a ranking encoder.